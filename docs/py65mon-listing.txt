
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output cthulhu-py65mon.bin platforms/platform-py65mon.asm
; Tue Apr 21 08:22:23 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platforms/platform-py65mon.asm

=true					DEBUG = true
=true					STRING_CR_TO_LF = true
=false					OCTAL = false
=$0000					ram_start = $0000       ; Start of RAM. Must contain the Zero Page
=$8000					ram_size  = $8000       ; assumes 32 KiB of RAM
=$0000					zp_start  = $0000       ; start of zero page,
=$80					zp_size   = $80         ; max bytes allowed in Zero Page
=$0200					buffers_start   = $0200         ; start of the buffer RAM area
=$100					cib_size        = $100          ; size of the input buffer, used by reader
=$100					tkb_size        = $100          ; size of the token buffer, used by lexer
=31744					heap_size       = ram_size - ($200+cib_size+tkb_size)
=$10					RAM_SEGMENT_AST  = $10   ; $1000 to $1FFF Abstract Symbol Tree (AST)
=$20					RAM_SEGMENT_STR  = $20   ; $2000 to $2FFF String Table and strings
=$f000					io_start = $f000
=$10					io_size  = $10
=$8000					rom_start = $8000                       ; $8000 by default
=28672					rom_size = io_start - rom_start         ; $f000 - $8000 = $7000 (28 KiB)
=$fffa					vectors_start = $fffa
=$ffff					max_address   = $ffff

;******  Processing file: platforms/../cthulhu.asm

.8000					cthulhu:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 06		sta $06		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 07		sta $07		                sta output+1
.8009	a9 10		lda #$10	                lda #RAM_SEGMENT_AST    ; AST, default nibble $10
.800b	85 15		sta $15		                sta rsn_ast
.800d	a9 20		lda #$20	                lda #RAM_SEGMENT_STR    ; Strings, default nibble $20
.800f	85 1a		sta $1a		                sta rsn_str
.8011	a0 02		ldy #$02	                ldy #$02          ; First free byte is one word down
.8013	84 1d		sty $1d		                sty hp_str
.8015	a5 1a		lda $1a		                lda rsn_str     ; MSB of RAM segment for strings
.8017	85 1e		sta $1e		                sta hp_str+1
.8019	85 1c		sta $1c		                sta strp+1
.801b	64 1b		stz $1b		                stz strp        ; LSB
.801d	a9 00		lda #$00	                lda #00
.801f	a8		tay		                tay
.8020	92 1d		sta ($1d)	                sta (hp_str)
.8022	c8		iny		                iny
.8023	91 1d		sta ($1d),y	                sta (hp_str),y
.8025	a9 21		lda #$21	                lda #<kernel_getc
.8027	85 08		sta $08		                sta input
.8029	a9 f0		lda #$f0	                lda #>kernel_putc
.802b	85 09		sta $09		                sta input+1
.802d					repl:

;******  Processing file: platforms/../reader.asm

.802d					reader:
.802d	64 0c		stz $0c		                stz input_f
.802f	64 0d		stz $0d		                stz ciblen
.8031	64 0e		stz $0e		                stz ciblen+1
.8033	a9 0b		lda #$0b	                lda #str_prompt
.8035	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.8038	a0 00		ldy #$00	                ldy #0
.803a					reader_loop:
.803a	20 b4 84	jsr $84b4	                        jsr help_key_a
.803d	c9 0a		cmp #$0a	                        cmp #AscLF
.803f	f0 3b		beq $807c	                        beq reader_got_eol
.8041	c9 0d		cmp #$0d	                        cmp #AscCR
.8043	f0 37		beq $807c	                        beq reader_got_eol
.8045					_not_an_eol:
.8045					_not_a_parens:
.8045	c9 3b		cmp #$3b	                        cmp #$3B                ; semicolon
.8047	d0 08		bne $8051	                        bne _not_a_comment
.8049	aa		tax		                        tax                     ; Save semicolon char
.804a	a9 80		lda #$80	                        lda #$80                ; Get ready to set bit 7
.804c	04 0c		tsb $0c		                        tsb input_f             ; 65c02 only
.804e	8a		txa		                        txa
.804f	80 1d		bra $806e	                        bra reader_comment_continue     ; saves char
.8051					_not_a_comment:
.8051	c9 22		cmp #$22	                        cmp #$22                ; quotation mark '"'
.8053	d0 0a		bne $805f	                        bne _not_a_string
.8055	aa		tax		                        tax                     ; Save quotation mark char
.8056	a5 0c		lda $0c		                        lda input_f
.8058	49 40		eor #$40	                        eor #%01000000          ; flip bit 6
.805a	85 0c		sta $0c		                        sta input_f
.805c	8a		txa		                        txa
.805d	80 0f		bra $806e	                        bra reader_string_continue      ; saves char
.805f					_not_a_string:
.805f	c9 08		cmp #$08	                        cmp #AscBS
.8061	f0 2e		beq $8091	                        beq reader_backspace
.8063	c9 7f		cmp #$7f	                        cmp #AscDEL             ; Is the same as CTRL-h
.8065	f0 2a		beq $8091	                        beq reader_backspace
.8067	c9 04		cmp #$04	                        cmp #$04
.8069	d0 03		bne $806e	                        bne reader_normal_char
.806b	4c 88 84	jmp $8488	                        jmp repl_quit
.806e					reader_normal_char:
.806e					reader_comment_continue:
.806e					reader_string_continue:
.806e	20 b1 84	jsr $84b1	                        jsr help_emit_a
.8071	99 00 02	sta $0200,y	                        sta cib,y
.8074	c8		iny		                        iny
.8075	cc 00 01	cpy $0100	                        cpy cib_size
.8078	90 34		bcc $80ae	                        bcc reader_buffer_full
.807a	80 be		bra $803a	                        bra reader_loop
.807c					reader_got_eol:
.807c	a5 0c		lda $0c		                        lda input_f             ; bit 7 marks comment
.807e	30 09		bmi $8089	                        bmi _eol_in_comment
.8080	29 7f		and #$7f	                        and #%01111111          ; input_f already in A
.8082	d0 09		bne $808d	                        bne _eol_in_parens_or_string
.8084	20 b1 84	jsr $84b1	                        jsr help_emit_a
.8087	80 25		bra $80ae	                        bra reader_input_done
.8089					_eol_in_comment:
.8089	a9 80		lda #$80	                        lda #$80
.808b	14 0c		trb $0c		                        trb input_f             ; bit 7 marks comment, now clear
.808d					_eol_in_parens_or_string:
.808d	a9 0a		lda #$0a	                        lda #AscLF
.808f	80 dd		bra $806e	                        bra reader_comment_continue       ; stores LF
.8091					reader_backspace:
.8091	c0 00		cpy #$00	                        cpy #0          ; buffer empty?
.8093	d0 06		bne $809b	                        bne _skip_bell
.8095	a9 07		lda #$07	                        lda #AscBELL
.8097	20 b1 84	jsr $84b1	                        jsr help_emit_a
.809a	c8		iny		                        iny
.809b					_skip_bell:
.809b	88		dey		                        dey
.809c	a9 08		lda #$08	                        lda #AscBS      ; move back one
.809e	20 b1 84	jsr $84b1	                        jsr help_emit_a
.80a1	a9 20		lda #$20	                        lda #AscSP      ; print a space (rubout)
.80a3	20 b1 84	jsr $84b1	                        jsr help_emit_a
.80a6	a9 08		lda #$08	                        lda #AscBS      ; move back over space
.80a8	20 b1 84	jsr $84b1	                        jsr help_emit_a
.80ab	4c 3a 80	jmp $803a	                        jmp reader_loop
.80ae					reader_input_done:
.80ae					reader_buffer_full:
.80ae	84 0d		sty $0d		                        sty ciblen      ; Y contains number of chars accepted already
.80b0	a9 00		lda #$00	                        lda #0
.80b2	85 0e		sta $0e		                        sta ciblen+1    ; we only accept 254 chars for now
.80b4	99 00 02	sta $0200,y	                        sta cib,y

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../lexer.asm

.80b7					lexer:
.80b7	20 82 85	jsr $8582	                jsr debug_dump_input
.80ba	a0 00		ldy #$00	                ldy #0
.80bc	64 0f		stz $0f		                stz cibp
.80be	64 10		stz $10		                stz cibp+1      ; MSB currently unused
.80c0	64 13		stz $13		                stz tkbp
.80c2	64 14		stz $14		                stz tkbp+1      ; MSB currently unused
.80c4	98		tya		                tya
.80c5	19 00 02	ora $0200,y	                ora cib,y
.80c8	d0 03		bne $80cd	                bne lexer_loop
.80ca	4c 85 84	jmp $8485	                jmp repl_empty_line
.80cd					lexer_loop:
.80cd	b9 00 02	lda $0200,y	                lda cib,y
.80d0	c9 3b		cmp #$3b	                cmp #$3B        ; semicolon
.80d2	d0 0f		bne $80e3	                bne _no_comment
.80d4					_comment_loop:
.80d4	c8		iny		                iny
.80d5	b9 00 02	lda $0200,y	                lda cib,y
.80d8	c9 0a		cmp #$0a	                cmp #AscLF
.80da	f0 04		beq $80e0	                beq _comment_done
.80dc	c9 0d		cmp #$0d	                cmp #AscCR
.80de	d0 f4		bne $80d4	                bne _comment_loop
.80e0					_comment_done:
.80e0	4c f6 81	jmp $81f6	                jmp lexer_next
.80e3					_no_comment:
.80e3	20 f8 84	jsr $84f8	                jsr help_is_whitespace
.80e6	90 03		bcc $80eb	                bcc _not_whitespace
.80e8	4c f6 81	jmp $81f6	                jmp lexer_next
.80eb					_not_whitespace:
.80eb					_test_parens:
.80eb	c9 28		cmp #$28	                cmp #'('        ; check for open parens
.80ed	d0 08		bne $80f7	                bne _not_parens_start
.80ef	a9 aa		lda #$aa	                lda #T_PAREN_START
.80f1	20 06 82	jsr $8206	                jsr lexer_add_token
.80f4	4c f6 81	jmp $81f6	                jmp lexer_next
.80f7					_not_parens_start:
.80f7	c9 29		cmp #$29	                cmp #')'        ; check for close parens
.80f9	d0 08		bne $8103	                bne _not_parens_end
.80fb	a9 ff		lda #$ff	                lda #T_PAREN_END
.80fd	20 06 82	jsr $8206	                jsr lexer_add_token
.8100	4c f6 81	jmp $81f6	                jmp lexer_next
.8103					_not_parens_end:
.8103	c9 27		cmp #$27	                cmp #$27                ; "'" tick for (quote)
.8105	d0 08		bne $810f	                bne _not_tick
.8107	a9 01		lda #$01	                lda #T_TICK
.8109	20 06 82	jsr $8206	                jsr lexer_add_token
.810c	4c f6 81	jmp $81f6	                jmp lexer_next
.810f					_not_tick:
.810f	d0 03		bne $8114	                bne _not_done
.8111	4c fe 81	jmp $81fe	                jmp lexer_end_of_input          ; not the same as lexer_done
.8114					_not_done:
.8114	c9 23		cmp #$23	                cmp #'#'
.8116	f0 03		beq $811b	                beq _got_sharp
.8118	4c b8 81	jmp $81b8	                jmp lexer_not_sharp             ; too far for branch
.811b					_got_sharp:
.811b	c8		iny		                iny
.811c	b9 00 02	lda $0200,y	                lda cib,y
.811f	c9 74		cmp #$74	                cmp #'t'        ; We're optimists so we check for true first
.8121	d0 08		bne $812b	                bne _not_true
.8123	a9 02		lda #$02	                lda #T_TRUE
.8125	20 06 82	jsr $8206	                jsr lexer_add_token
.8128	4c f6 81	jmp $81f6	                jmp lexer_next
.812b					_not_true:
.812b	c9 66		cmp #$66	                cmp #'f'
.812d	d0 08		bne $8137	                bne _not_false
.812f	a9 03		lda #$03	                lda #T_FALSE
.8131	20 06 82	jsr $8206	                jsr lexer_add_token
.8134	4c f6 81	jmp $81f6	                jmp lexer_next
.8137					_not_false:
.8137	c9 5c		cmp #$5c	                cmp #'\'
.8139	d0 00		bne $813b	                bne _no_backslash
.813b					_not_single_char:
.813b					_not_named_char:
.813b					_no_backslash:
.813b					_not_vector:
.813b	c9 78		cmp #$78	                cmp #'x'        ; #x is hexadecimal
.813d	d0 04		bne $8143	                bne _not_hexnum
.813f	a9 10		lda #$10	                lda #$10        ; Base 16
.8141	80 13		bra $8156	                bra lexer_got_number
.8143					_not_hexnum:
.8143	c9 62		cmp #$62	                cmp #'b'        ; #b is binary
.8145	d0 04		bne $814b	                bne _not_binnum
.8147	a9 02		lda #$02	                lda #$02        ; Base 2
.8149	80 0b		bra $8156	                bra lexer_got_number
.814b					_not_binnum:
.814b	c9 64		cmp #$64	                cmp #'d'        ; #d is explicit decimal
.814d	d0 04		bne $8153	                bne _illegal_radix
.814f	a9 0a		lda #$0a	                lda #$0A        ; Base 10
.8151	80 03		bra $8156	                bra lexer_got_number
.8153					_illegal_radix:
.8153	4c b0 81	jmp $81b0	                jmp lexer_illegal_radix
.8156					lexer_got_number:
.8156	48		pha		                pha                     ; Save the radix for the moment
.8157	a9 12		lda #$12	                lda #T_NUM_START
.8159	20 06 82	jsr $8206	                jsr lexer_add_token
.815c	68		pla		                pla
.815d	20 06 82	jsr $8206	                jsr lexer_add_token
.8160	a6 13		ldx $13		                ldx tkbp        ; get index of where length will be
.8162	86 00		stx $00		                stx tmp0
.8164	a9 00		lda #$00	                lda #0          ; dummy length value
.8166	20 06 82	jsr $8206	                jsr lexer_add_token
.8169	c8		iny		                iny             ; Y is still the input buffer index
.816a	b9 00 02	lda $0200,y	                lda cib,y
.816d	a2 00		ldx #$00	                ldx #0          ; X counts length of string
.816f	c9 2d		cmp #$2d	                cmp #'-'
.8171	d0 09		bne $817c	                bne _check_for_plus
.8173	a9 21		lda #$21	                lda #T_MINUS
.8175	20 06 82	jsr $8206	                jsr lexer_add_token
.8178	c8		iny		                iny             ; skip minus character
.8179	e8		inx		                inx             ; string now has length of 1
.817a	80 0b		bra $8187	                bra _sign_done
.817c					_check_for_plus:
.817c	c9 2b		cmp #$2b	                cmp #'+'
.817e	d0 01		bne $8181	                bne _default_plus
.8180	c8		iny		                iny
.8181					_default_plus:
.8181	a9 20		lda #$20	                lda #T_PLUS
.8183	20 06 82	jsr $8206	                jsr lexer_add_token
.8186	e8		inx		                inx             ; string now has length of 1
.8187					_sign_done:
.8187	b9 00 02	lda $0200,y	                lda cib,y
.818a	f0 24		beq $81b0	                beq lexer_terminator_too_early  ; 00 terminates input
.818c	20 e5 84	jsr $84e5	                jsr help_is_delimiter
.818f	b0 1f		bcs $81b0	                bcs lexer_delimiter_too_early
.8191					_number_loop:
.8191	20 06 82	jsr $8206	                jsr lexer_add_token
.8194	e8		inx		                inx             ; String one character longer
.8195	c8		iny		                iny             ; Next character
.8196	b9 00 02	lda $0200,y	                lda cib,y
.8199	f0 07		beq $81a2	                beq _legal_terminator
.819b	20 e5 84	jsr $84e5	                jsr help_is_delimiter
.819e	b0 02		bcs $81a2	                bcs _number_done
.81a0	80 ef		bra $8191	                bra _number_loop
.81a2					_legal_terminator:
.81a2					_number_done:
.81a2	a9 82		lda #$82	                lda #T_NUM_END
.81a4	20 06 82	jsr $8206	                jsr lexer_add_token
.81a7	8a		txa		                txa             ; number of chars was in X
.81a8	a6 00		ldx $00		                ldx tmp0        ; index of length byte in token stream
.81aa	9d 00 03	sta $0300,x	                sta tkb,x
.81ad	4c f7 81	jmp $81f7	                jmp lexer_next_same_char
.81b0					lexer_illegal_radix:
.81b0					lexer_terminator_too_early:
.81b0					lexer_delimiter_too_early:
.81b0	a9 06		lda #$06	                lda #str_bad_number
.81b2	20 d1 84	jsr $84d1	                jsr help_print_string
.81b5	4c 2d 80	jmp $802d	                jmp repl
.81b8					lexer_not_octnum
.81b8					lexer_not_sharp:
.81b8					_not_decnum:
.81b8	c9 22		cmp #$22	                cmp #$22        ; '"' ASCII value
.81ba	d0 1f		bne $81db	                bne _not_string
.81bc	a9 13		lda #$13	                lda #T_STR_START
.81be	20 06 82	jsr $8206	                jsr lexer_add_token
.81c1					_string_loop:
.81c1	c8		iny		                iny
.81c2	b9 00 02	lda $0200,y	                lda cib,y
.81c5	c9 22		cmp #$22	                cmp #$22        ; '"' closes string
.81c7	f0 0b		beq $81d4	                beq _string_done
.81c9	c9 0d		cmp #$0d	                cmp #AscCR
.81cb	d0 02		bne $81cf	                bne +
.81cd	a9 0a		lda #$0a	                lda #AscLF
.81cf					+
.81cf	20 06 82	jsr $8206	                jsr lexer_add_token
.81d2	80 ed		bra $81c1	                bra _string_loop
.81d4					_string_done:
.81d4	a9 83		lda #$83	                lda #T_STR_END
.81d6	20 06 82	jsr $8206	                jsr lexer_add_token
.81d9	80 1b		bra $81f6	                bra lexer_next
.81db					_not_string:
.81db	c9 2e		cmp #$2e	                cmp #'.'
.81dd	d0 07		bne $81e6	                bne _not_dot
.81df	a9 05		lda #$05	                lda #T_DOT
.81e1	20 06 82	jsr $8206	                jsr lexer_add_token
.81e4	80 10		bra $81f6	                bra lexer_next
.81e6					_not_dot:
.81e6					lexer_error:
.81e6	48		pha		                pha
.81e7	a9 00		lda #$00	                lda #str_unbound
.81e9	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.81ec	68		pla		                pla
.81ed	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.81f0	20 af 84	jsr $84af	                jsr help_emit_lf
.81f3	4c 2d 80	jmp $802d	                jmp repl
.81f6					lexer_next:
.81f6	c8		iny		                iny
.81f7					lexer_next_same_char:
.81f7	c4 0d		cpy $0d		                cpy ciblen
.81f9	f0 03		beq $81fe	                beq lexer_end_of_input
.81fb	4c cd 80	jmp $80cd	                jmp lexer_loop
.81fe					lexer_end_of_input:
.81fe	a9 00		lda #$00	                lda #T_END
.8200	20 06 82	jsr $8206	                jsr lexer_add_token
.8203	4c 11 82	jmp $8211	                jmp lexer_done
.8206					lexer_add_token:
.8206	5a		phy		                phy             ; Could also store in cibp
.8207	a4 13		ldy $13		                ldy tkbp
.8209	99 00 03	sta $0300,y	                sta tkb,y       ; LSB is in A
.820c	c8		iny		                iny
.820d	84 13		sty $13		                sty tkbp
.820f	7a		ply		                ply
.8210	60		rts		                rts
=$00					T_END           = $00   ; Terminates token stream
=$01					T_TICK          = $01   ; "'" - tick character
=$02					T_TRUE          = $02   ; '#t'
=$03					T_FALSE         = $03   ; '#f'
=$04					T_SHARP         = $04   ; '#' - note '#f', '#t' and others are precprocessed
=$05					T_DOT           = $05   ; "." - dot/period, used for pairs
=$12					T_NUM_START     = $12   ; Marks beginning of a number sequence
=$13					T_STR_START     = $13   ; Marks beginning of a string
=$14					T_ID_START      = $14   ; Marks beginning of an identifier
=$20					T_PLUS          = $20   ; '+' Also used in number token sequence
=$21					T_MINUS         = $21   ; '-' Also used in number token sequence
=$22					T_STAR          = $22   ; '*' Also used for math
=$23					T_SLASH         = $23   ; '\' Also used for math
=$82					T_NUM_END       = $82   ; Marks end of a number sequence, see T_NUM_START
=$83					T_STR_END       = $83   ; Marks end of a string, see T_STR_START
=$84					T_ID_END        = $84   ; Makrs end of an identifier, see T_ID_START
=$aa					T_PAREN_START   = $AA   ; '(' - parens open
=$ff					T_PAREN_END     = $FF   ; ')' - parens closed
.8211					lexer_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../parser.asm

.8211					parser:
.8211	20 9f 85	jsr $859f	                jsr debug_dump_token
.8214	a9 02		lda #$02	                lda #$02        ; Skip dummy cdr at beginning of RAM
.8216	85 18		sta $18		                sta hp_ast
.8218	a5 15		lda $15		                lda rsn_ast     ; MSB of RAM segment for AST
.821a	85 19		sta $19		                sta hp_ast+1
.821c	85 17		sta $17		                sta astp+1      ; still have MSB of RAM segment
.821e	64 16		stz $16		                stz astp
.8220	64 13		stz $13		                stz tkbp
.8222	64 14		stz $14		                stz tkbp+1      ; fake, currently only using LSB
.8224	a2 ff		ldx #$ff	                ldx #$FF        ; index -1 at beginning
.8226					parser_loop:
.8226	e8		inx		                inx
.8227	bd 00 03	lda $0300,x	                lda tkb,x
.822a	c9 01		cmp #$01	                cmp #T_TICK
.822c	d0 0a		bne $8238	                bne _not_tick
.822e	a9 02		lda #$02	                lda #<OC_PROC_QUOTE
.8230	a0 f0		ldy #$f0	                ldy #>OC_PROC_QUOTE
.8232	20 7b 83	jsr $837b	                jsr parser_add_object_to_ast
.8235	4c 26 82	jmp $8226	                jmp parser_loop
.8238					_not_tick:
.8238	c9 aa		cmp #$aa	                cmp #T_PAREN_START
.823a	d0 00		bne $823c	                bne _not_paren_start
.823c					_not_paren_start:
.823c	c9 ff		cmp #$ff	                cmp #T_PAREN_END
.823e	d0 00		bne $8240	                bne _not_paren_end
.8240					_not_paren_end:
.8240	c9 00		cmp #$00	                cmp #T_END
.8242	d0 03		bne $8247	                bne _not_end_token
.8244	4c ba 83	jmp $83ba	                jmp parser_done
.8247					_not_end_token:
.8247	c9 02		cmp #$02	                cmp #T_TRUE
.8249	d0 0a		bne $8255	                bne _not_true_token
.824b	a9 ff		lda #$ff	                lda <#OC_TRUE
.824d	a0 1f		ldy #$1f	                ldy >#OC_TRUE
.824f	20 7b 83	jsr $837b	                jsr parser_add_object_to_ast
.8252	4c 26 82	jmp $8226	                jmp parser_loop
.8255					_not_true_token:
.8255	c9 03		cmp #$03	                cmp #T_FALSE
.8257	d0 0a		bne $8263	                bne _not_false_token
.8259	a9 00		lda #$00	                lda <#OC_FALSE
.825b	a0 10		ldy #$10	                ldy >#OC_FALSE
.825d	20 7b 83	jsr $837b	                jsr parser_add_object_to_ast
.8260	4c 26 82	jmp $8226	                jmp parser_loop
.8263					_not_false_token:
.8263	c9 12		cmp #$12	                cmp #T_NUM_START
.8265	f0 03		beq $826a	                beq +
.8267	4c 10 83	jmp $8310	                jmp parser_not_num      ; too far for BNE
.826a					+
.826a	64 02		stz $02		                stz tmp1
.826c	64 03		stz $03		                stz tmp1+1
.826e	e8		inx		                inx             ; skip over T_NUM_START token
.826f	bd 00 03	lda $0300,x	                lda tkb,x
.8272	85 00		sta $00		                sta tmp0        ; radix
.8274	e8		inx		                inx
.8275	bd 00 03	lda $0300,x	                lda tkb,x
.8278	a8		tay		                tay             ; We need the length of the string later ...
.8279	88		dey		                dey             ; ... but we don't need to include the sign
.827a	e8		inx		                inx             ; Move to token for sign, T_PLUS or T_MINUS
.827b	bd 00 03	lda $0300,x	                lda tkb,x
.827e	85 01		sta $01		                sta tmp0+1      ; Just store sign for now
.8280	e8		inx		                inx             ; Move to first digit
.8281	a5 00		lda $00		                lda tmp0        ; radix
.8283	c9 0a		cmp #$0a	                cmp #$0a
.8285	d0 03		bne $828a	                bne _not_dec
.8287	4c f8 82	jmp $82f8	                jmp parser_common_fixnum
.828a					_not_dec:
.828a	c9 10		cmp #$10	                cmp #$10
.828c	d0 36		bne $82c4	                bne _not_hex
.828e	98		tya		                tya
.828f	c9 04		cmp #$04	                cmp #$04
.8291	90 03		bcc $8296	                bcc _dec_fixnum
.8293	4c 73 83	jmp $8373	                jmp function_not_available
.8296					_dec_fixnum:
.8296					_hex_fixnum_loop:
.8296	bd 00 03	lda $0300,x	                lda tkb,x
.8299	c9 82		cmp #$82	                cmp #T_NUM_END
.829b	f0 24		beq $82c1	                beq _done_hex
.829d	20 0f 85	jsr $850f	                jsr help_hexascii_to_value
.82a0	10 03		bpl $82a5	                bpl _legal_hex_digit
.82a2	4c 6b 83	jmp $836b	                jmp parser_bad_digit
.82a5					_legal_hex_digit:
.82a5	0a		asl a		                asl
.82a6	0a		asl a		                asl
.82a7	0a		asl a		                asl
.82a8	0a		asl a		                asl
.82a9	2a		rol a		                rol             ; bit 7 of A now in carry flag
.82aa	26 03		rol $03		                rol tmp1+1      ; bit 7 of tmp1+1 now in carry flag
.82ac	26 02		rol $02		                rol tmp1        ; now is bit 0 of tmp1
.82ae	2a		rol a		                rol
.82af	26 03		rol $03		                rol tmp1+1
.82b1	26 02		rol $02		                rol tmp1
.82b3	2a		rol a		                rol
.82b4	26 03		rol $03		                rol tmp1+1
.82b6	26 02		rol $02		                rol tmp1
.82b8	2a		rol a		                rol
.82b9	26 03		rol $03		                rol tmp1+1
.82bb	26 02		rol $02		                rol tmp1
.82bd	e8		inx		                inx
.82be	88		dey		                dey
.82bf	d0 d5		bne $8296	                bne _hex_fixnum_loop
.82c1					_done_hex:
.82c1	4c f8 82	jmp $82f8	                jmp parser_common_fixnum
.82c4					_not_hex:
.82c4	c9 02		cmp #$02	                cmp #$02
.82c6	d0 28		bne $82f0	                bne _not_binary
.82c8	98		tya		                tya
.82c9	c9 0d		cmp #$0d	                cmp #$0D                ; "smaller than 13"
.82cb	90 03		bcc $82d0	                bcc _bin_fixnum
.82cd	4c 73 83	jmp $8373	                jmp function_not_available
.82d0					_bin_fixnum:
.82d0					_bin_fixnum_loop:
.82d0	bd 00 03	lda $0300,x	                lda tkb,x
.82d3	c9 30		cmp #$30	                cmp #'0'
.82d5	f0 0b		beq $82e2	                beq _legal_bit_char
.82d7	c9 31		cmp #$31	                cmp #'1'
.82d9	f0 07		beq $82e2	                beq _legal_bit_char
.82db	c9 82		cmp #$82	                cmp #T_NUM_END
.82dd	f0 0e		beq $82ed	                beq _done_bin
.82df	4c 6b 83	jmp $836b	                jmp parser_bad_digit
.82e2					_legal_bit_char:
.82e2	29 01		and #$01	                and #$01                ; gives us $00 or $01
.82e4	6a		ror a		                ror                     ; push the bit into carry flag
.82e5	26 03		rol $03		                rol tmp1+1              ; rotate the carry flag into LSB ...
.82e7	26 02		rol $02		                rol tmp1                ; ... and highest bit of tmp1+1 to tmp1
.82e9	e8		inx		                inx                     ; next character
.82ea	88		dey		                dey                     ; decrease counter
.82eb	d0 e3		bne $82d0	                bne _bin_fixnum_loop
.82ed					_done_bin:
.82ed	4c f8 82	jmp $82f8	                jmp parser_common_fixnum
.82f0					_not_binary:
.82f0					_illegal_radix:
.82f0	48		pha		                pha                             ; save the evil radix
.82f1	a9 07		lda #$07	                lda #str_bad_radix
.82f3	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.82f6	80 69		bra $8361	                bra parser_common_panic         ; prints offending byte and LF
.82f8					parser_common_fixnum:
.82f8	a5 01		lda $01		                lda tmp0+1
.82fa	c9 21		cmp #$21	                cmp #T_MINUS
.82fc	f0 08		beq $8306	                beq _negative_number
.82fe	a9 20		lda #$20	                lda #OT_FIXNUM
.8300	05 02		ora $02		                ora tmp1        ; construct tag byte with MSB of number
.8302	85 02		sta $02		                sta tmp1
.8304	80 00		bra $8306	                bra _add_fixnum_to_ast
.8306					_negative_number:
.8306					_add_fixnum_to_ast:
.8306	a5 03		lda $03		                lda tmp1+1
.8308	a4 02		ldy $02		                ldy tmp1
.830a	20 7b 83	jsr $837b	                jsr parser_add_object_to_ast
.830d					_num_done:
.830d	4c 26 82	jmp $8226	                jmp parser_loop
.8310					parser_not_num:
.8310	c9 13		cmp #$13	                cmp #T_STR_START
.8312	d0 47		bne $835b	                bne parser_not_string
.8314	a5 1e		lda $1e		                lda hp_str+1    ; MSB of next free byte in string RAM segment
.8316	29 0f		and #$0f	                and #$0F        ; mask high nibble (paranoid)
.8318	09 50		ora #$50	                ora #OT_STRING  ; object tag nibble for strings
.831a	a8		tay		                tay             ; MSB goes in Y
.831b	a5 1d		lda $1d		                lda hp_str      ; LSB goes in A
.831d	20 7b 83	jsr $837b	                jsr parser_add_object_to_ast   ; Updates AST heap pointer
.8320	e8		inx		                inx             ; move to first character of string
.8321	a0 00		ldy #$00	                ldy #0
.8323					_string_loop:
.8323	bd 00 03	lda $0300,x	                lda tkb,x
.8326	c9 83		cmp #$83	                cmp #T_STR_END
.8328	f0 06		beq $8330	                beq _string_end
.832a	91 1d		sta ($1d),y	                sta (hp_str),y
.832c	c8		iny		                iny
.832d	e8		inx		                inx
.832e	80 f3		bra $8323	                bra _string_loop
.8330					_string_end:
.8330	a9 00		lda #$00	                lda #0
.8332	c8		iny		                iny
.8333	91 1d		sta ($1d),y	                sta (hp_str),y
.8335	98		tya		                tya
.8336	18		clc		                clc
.8337	65 1d		adc $1d		                adc hp_str
.8339	85 1d		sta $1d		                sta hp_str
.833b	90 02		bcc $833f	                bcc +
.833d	e6 1e		inc $1e		                inc hp_str+1
.833f					+
.833f	a9 00		lda #$00	                lda #0
.8341	92 1d		sta ($1d)	                sta (hp_str)
.8343	a0 01		ldy #$01	                ldy #1
.8345	91 1d		sta ($1d),y	                sta (hp_str),y
.8347	a5 1d		lda $1d		                lda hp_str
.8349	85 1b		sta $1b		                sta strp
.834b	a5 1e		lda $1e		                lda hp_str+1
.834d	85 1c		sta $1c		                sta strp+1
.834f	98		tya		                tya             ; #1
.8350	1a		inc a		                inc a
.8351	18		clc		                clc
.8352	65 1d		adc $1d		                adc hp_str
.8354	90 02		bcc $8358	                bcc +
.8356	e6 1e		inc $1e		                inc hp_str+1
.8358					+
.8358	4c 26 82	jmp $8226	                jmp parser_loop
.835b					parser_not_string:
.835b					paser_bad_token:
.835b	48		pha		                pha                             ; save the evil token
.835c	a9 04		lda #$04	                lda #str_bad_token
.835e	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.8361					parser_common_panic:
.8361	68		pla		                pla
.8362	20 98 84	jsr $8498	                jsr help_byte_to_ascii          ; print bad token as hex number
.8365	20 af 84	jsr $84af	                jsr help_emit_lf
.8368	4c 2d 80	jmp $802d	                jmp repl
.836b					parser_bad_digit:
.836b	48		pha		                pha
.836c	a9 06		lda #$06	                lda #str_bad_number
.836e	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.8371	80 ee		bra $8361	                bra parser_common_panic
.8373					function_not_available:
.8373	a9 08		lda #$08	                lda #str_cant_yet
.8375	20 d1 84	jsr $84d1	                jsr help_print_string
.8378	4c 2d 80	jmp $802d	                jmp repl
.837b					parser_add_object_to_ast:
.837b	da		phx		                phx             ; save index to token buffer
.837c	5a		phy		                phy             ; save MSB of the object (with tag)
.837d	48		pha		                pha             ; save LSB of the object
.837e	a5 18		lda $18		                lda hp_ast
.8380	85 00		sta $00		                sta tmp0
.8382	a5 19		lda $19		                lda hp_ast+1
.8384	85 01		sta $01		                sta tmp0+1
.8386	a9 00		lda #$00	                lda <#OC_EMPTY_LIST
.8388	a0 00		ldy #$00	                ldy #0
.838a	91 18		sta ($18),y	                sta (hp_ast),y
.838c	c8		iny		                iny
.838d	a9 00		lda #$00	                lda >#OC_EMPTY_LIST
.838f	91 18		sta ($18),y	                sta (hp_ast),y
.8391	c8		iny		                iny
.8392	68		pla		                pla             ; retrieve LSB of object, was in A
.8393	91 18		sta ($18),y	                sta (hp_ast),y
.8395	c8		iny		                iny
.8396	68		pla		                pla             ; retrieve MSB (with tag), was in Y
.8397	91 18		sta ($18),y	                sta (hp_ast),y
.8399	c8		iny		                iny
.839a	98		tya		                tya
.839b	18		clc		                clc
.839c	65 18		adc $18		                adc hp_ast
.839e	85 18		sta $18		                sta hp_ast
.83a0	90 02		bcc $83a4	                bcc _store_address
.83a2	e6 19		inc $19		                inc hp_ast+1
.83a4					_store_address:
.83a4	a5 01		lda $01		                lda tmp0+1      ; original MSB of hp_ast, which is just an addr
.83a6	29 0f		and #$0f	                and #$0F        ; mask whatever the high nibble was (paranoid)
.83a8	09 80		ora #$80	                ora #OT_PAIR
.83aa	a0 01		ldy #$01	                ldy #1
.83ac	91 16		sta ($16),y	                sta (astp),y
.83ae	a5 00		lda $00		                lda tmp0        ; original LSB of hp_ast
.83b0	92 16		sta ($16)	                sta (astp)
.83b2	85 16		sta $16		                sta astp        ; still have original LSB
.83b4	a5 01		lda $01		                lda tmp0+1
.83b6	85 17		sta $17		                sta astp+1      ; MSB, was tmp0+1
.83b8	fa		plx		                plx             ; get back index for token buffer
.83b9	60		rts		                rts
=$0000					OC_EMPTY_LIST = $0000   ; end of list terminating object "()"
=$1fff					OC_TRUE       = $1fff   ; true bool #t, immediate
=$1000					OC_FALSE      = $1000   ; false bool #f, immediate
=$f000					OC_PROC_APPLY = $F000   ; primitive procedure (apply)
=$f002					OC_PROC_QUOTE = $F002   ; primitive procedure (quote)
.83ba					parser_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../eval.asm

.83ba					eval:
.83ba	20 d2 85	jsr $85d2	                jsr debug_dump_ast
.83bd	20 c0 85	jsr $85c0	                jsr debug_dump_hp
.83c0	a5 15		lda $15		                lda rsn_ast             ; RAM segment nibble, default $10
.83c2	a0 02		ldy #$02	                ldy #2                  ; by definition
.83c4	20 37 85	jsr $8537	                jsr help_walk_init      ; returns car in A and Y
.83c7					eval_loop:
.83c7	08		php		                php
.83c8	29 f0		and #$f0	                and #$f0
.83ca	4a		lsr a		                lsr
.83cb	4a		lsr a		                lsr
.83cc	4a		lsr a		                lsr             ; fourth LSR and ASL cancle each other out
.83cd	aa		tax		                tax
.83ce	7c e9 83	jmp ($83e9,x)	                jmp (eval_table,X)
.83d1					eval_next:
.83d1	28		plp		                plp
.83d2	b0 35		bcs $8409	                bcs eval_done           ; probably later a JMP
.83d4	20 3d 85	jsr $853d	                jsr help_walk_next
.83d7	80 ee		bra $83c7	                bra eval_loop
.83d9					eval_0_meta:
.83d9					eval_1_bool:
.83d9					eval_2_fixnum:
.83d9					eval_3_bignum:
.83d9					eval_4_char:
.83d9					eval_5_string:
.83d9	80 f6		bra $83d1	                bra eval_next           ; paranoid, never reached
.83db					eval_6_UNDEFINED:
.83db					eval_7_UNDEFINED:
.83db					eval_8_pair:
.83db	80 f4		bra $83d1	                bra eval_next   ; paranoid, currently not reached
.83dd					eval_9_UNDEFINED:
.83dd					eval_A_UNDEFINED:
.83dd					eval_B_UNDEFINED:
.83dd					eval_C_UNDEFINED:
.83dd					eval_D_UNDEFINED:
.83dd					eval_E_UNDEFINED:
.83dd					eval_f_proc:
.83dd	98		tya		        tya
.83de	b9 7c 85	lda $857c,y	        lda proc_table_lsb,y    ; LSB of jump target
.83e1	85 0a		sta $0a		        sta jump
.83e3	b9 7f 85	lda $857f,y	        lda proc_table_msb,y    ; MSB of jump target
.83e6	6c 0a 00	jmp ($000a)	        jmp (jump)
.83e9					eval_table:
>83e9	09 84 d1 83 d1 83 d1 83		        .word eval_done, eval_next, eval_next, eval_next
>83f1	d1 83 d1 83 d1 83 d1 83		        .word eval_next, eval_next, eval_next, eval_next
>83f9	db 83 d1 83 d1 83 d1 83		        .word eval_8_pair, eval_next, eval_next, eval_next
>8401	d1 83 d1 83 d1 83 dd 83		        .word eval_next, eval_next, eval_next, eval_f_proc
.8409					eval_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../printer.asm

.8409					printer:
.8409	20 d2 85	jsr $85d2	                jsr debug_dump_ast
.840c	a5 15		lda $15		                lda rsn_ast     ; RAM segment nibble
.840e	a0 02		ldy #$02	                ldy #02         ; by definition
.8410	20 37 85	jsr $8537	                jsr help_walk_init
.8413					printer_loop:
.8413	08		php		                php
.8414	29 f0		and #$f0	                and #$f0        ; mask all but tag nibble
.8416	4a		lsr a		                lsr
.8417	4a		lsr a		                lsr
.8418	4a		lsr a		                lsr     ; Fourth LSR and ASL cancle each other
.8419	aa		tax		                tax
.841a	20 af 84	jsr $84af	                jsr help_emit_lf
.841d	7c 62 84	jmp ($8462,x)	                jmp (printer_table,X)
.8420					printer_next:
.8420	28		plp		                plp                     ; from PHP
.8421	b0 5f		bcs $8482	                bcs printer_done        ; probably a JMP later
.8423	20 3d 85	jsr $853d	                jsr help_walk_next
.8426	80 eb		bra $8413	                bra printer_loop
.8428					printer_0_meta:
.8428	80 58		bra $8482	                bra printer_done
.842a					printer_1_bool:
.842a	a5 22		lda $22		                lda walk_car+1          ; MSB of car
.842c	29 0f		and #$0f	                and #$0F                ; Get rid of tag
.842e	05 21		ora $21		                ora walk_car
.8430	d0 04		bne $8436	                bne _bool_true          ; not a zero means true
.8432	a9 03		lda #$03	                lda #str_false
.8434	80 02		bra $8438	                bra _bool_printer
.8436					_bool_true:
.8436	a9 02		lda #$02	                lda #str_true
.8438					_bool_printer:
.8438	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.843b	80 e3		bra $8420	                bra printer_next
.843d					printer_2_fixnum:
.843d	a5 22		lda $22		                lda walk_car+1          ; MSB
.843f	29 0f		and #$0f	                and #$0F                ; Mask tag
.8441	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.8444	98		tya		                tya                     ; still Y
.8445	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.8448	80 d6		bra $8420	                bra printer_next
.844a					printer_3_bignum:
.844a					printer_4_char:
.844a					printer_5_string:
.844a	a5 22		lda $22		                lda walk_car+1          ; MSB
.844c	29 0f		and #$0f	                and #$0F                ; mask tag
.844e	05 1a		ora $1a		                ora rsn_str             ; merge with section nibble instead
.8450	85 05		sta $05		                sta tmp2+1
.8452	84 04		sty $04		                sty tmp2                ; LSB
.8454	a0 00		ldy #$00	                ldy #0
.8456					_string_loop:
.8456	b1 04		lda ($04),y	                lda (tmp2),y
.8458	f0 c6		beq $8420	                beq printer_next       ; string is zero terminated
.845a	20 b1 84	jsr $84b1	                jsr help_emit_a
.845d	c8		iny		                iny
.845e	80 f6		bra $8456	                bra _string_loop
.8460					printer_6_UNDEFINED:
.8460					printer_7_UNDEFINED:
.8460					printer_8_UNDEFINED:
.8460					printer_9_UNDEFINED:
.8460					printer_A_UNDEFINED:
.8460					printer_B_UNDEFINED:
.8460					printer_C_UNDEFINED:
.8460					printer_D_UNDEFINED:
.8460					printer_E_UNDEFINED:
.8460					printer_F_UNDEFINED:
.8460	80 be		bra $8420	                bra printer_next
.8462					printer_table:
>8462	82 84 2a 84 3d 84 20 84		        .word printer_done, printer_1_bool, printer_2_fixnum, printer_next
>846a	20 84 4a 84 20 84 20 84		        .word printer_next, printer_5_string, printer_next, printer_next
>8472	20 84 20 84 20 84 20 84		        .word printer_next, printer_next, printer_next, printer_next
>847a	20 84 20 84 20 84 20 84		        .word printer_next, printer_next, printer_next, printer_next
.8482					printer_done:
.8482	20 af 84	jsr $84af	                jsr help_emit_lf

;******  Return to file: platforms/../cthulhu.asm

.8485					repl_empty_line:
.8485	4c 2d 80	jmp $802d	                jmp repl
.8488					repl_quit:
.8488	20 af 84	jsr $84af	                jsr help_emit_lf
.848b	a9 09		lda #$09	                lda #str_end_input
.848d	20 d1 84	jsr $84d1	                jsr help_print_string
.8490	a9 0a		lda #$0a	                lda #str_chant
.8492	20 d1 84	jsr $84d1	                jsr help_print_string
.8495	4c 2b f0	jmp $f02b	                jmp platform_quit

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../helpers.asm

.8498					help_byte_to_ascii:
.8498	48		pha		                pha
.8499	4a		lsr a		                lsr             ; convert high nibble first
.849a	4a		lsr a		                lsr
.849b	4a		lsr a		                lsr
.849c	4a		lsr a		                lsr
.849d	20 a1 84	jsr $84a1	                jsr help_nibble_to_ascii
.84a0	68		pla		                pla
.84a1					help_nibble_to_ascii:
.84a1	29 0f		and #$0f	                and #$0F
.84a3	09 30		ora #$30	                ora #'0'
.84a5	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.84a7	90 02		bcc $84ab	                bcc +
.84a9	69 06		adc #$06	                adc #$06
.84ab	4c b1 84	jmp $84b1	+               jmp help_emit_a       ; JSR/RTS
.84ae					help_to_lowercase:
.84ae	60		rts		                rts
.84af					help_emit_lf:
.84af	a9 0a		lda #$0a	                lda #AscLF
.84b1					help_emit_a:
.84b1	6c 06 00	jmp ($0006)	                jmp (output)    ; JSR/RTS
.84b4					help_key_a:
.84b4	6c 08 00	jmp ($0008)	                jmp (input)             ; JSR/RTS
.84b7					help_print_string_no_lf:
.84b7	0a		asl a		                asl
.84b8	a8		tay		                tay
.84b9	b9 b9 86	lda $86b9,y	                lda string_table,y
.84bc	85 00		sta $00		                sta tmp0                ; LSB
.84be	c8		iny		                iny
.84bf	b9 b9 86	lda $86b9,y	                lda string_table,y
.84c2	85 01		sta $01		                sta tmp0+1              ; MSB
.84c4					help_print_common:
.84c4	a0 00		ldy #$00	                ldy #0
.84c6					_loop:
.84c6	b1 00		lda ($00),y	                lda (tmp0),y
.84c8	f0 06		beq $84d0	                beq _done               ; strings are zero-terminated
.84ca	20 b1 84	jsr $84b1	                jsr help_emit_a         ; allows vectoring via output
.84cd	c8		iny		                iny
.84ce	80 f6		bra $84c6	                bra _loop
.84d0					_done:
.84d0	60		rts		                rts
.84d1					help_print_string:
.84d1	20 b7 84	jsr $84b7	                jsr help_print_string_no_lf
.84d4	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.84d6	4c b1 84	jmp $84b1	                jmp help_emit_a         ; JSR/RTS
.84d9					help_is_decdigit:
.84d9	c9 30		cmp #$30	                cmp #'0'
.84db	90 07		bcc $84e4	                bcc _below_zero         ; A is < '0'
.84dd	c9 3a		cmp #$3a	                cmp #':'                ; A is >= ':', which is '9'+1
.84df	b0 02		bcs $84e3	                bcs _above_nine
.84e1	38		sec		                sec
.84e2	60		rts		                rts
.84e3					_above_nine:
.84e3	18		clc		                clc
.84e4					_below_zero:
.84e4	60		rts		                rts
.84e5					help_is_delimiter:
.84e5	20 f8 84	jsr $84f8	                jsr help_is_whitespace
.84e8	b0 0d		bcs $84f7	                bcs _delimiter_done
.84ea	18		clc		                clc
.84eb	c9 28		cmp #$28	                cmp #$28        ; '('
.84ed	f0 07		beq $84f6	                beq _is_delimiter
.84ef	c9 29		cmp #$29	                cmp #$29        ; ')'
.84f1	f0 03		beq $84f6	                beq _is_delimiter
.84f3	18		clc		                clc
.84f4	80 01		bra $84f7	                bra _delimiter_done
.84f6					_is_delimiter:
.84f6	38		sec		                sec
.84f7					_delimiter_done:
.84f7	60		rts		                rts
.84f8					help_is_whitespace:
.84f8	38		sec		                sec             ; default is whitespace
.84f9	c9 20		cmp #$20	                cmp #$20        ; SPACE, assumed to be the most common char
.84fb	f0 11		beq $850e	                beq _done
.84fd	c9 09		cmp #$09	                cmp #$09        ; TAB, probably the second most common in Scheme
.84ff	f0 0d		beq $850e	                beq _done
.8501	c9 0a		cmp #$0a	                cmp #$0A        ; Linefeed, normally ends input but not with Scheme
.8503	f0 09		beq $850e	                beq _done
.8505	c9 0d		cmp #$0d	                cmp #$0D        ; Return, normally ends input but not with Scheme
.8507	f0 05		beq $850e	                beq _done
.8509	c9 0c		cmp #$0c	                cmp #$0C        ; Page, which is strange, but in the standard
.850b	f0 01		beq $850e	                beq _done
.850d	18		clc		                clc             ; If we end up here, it's not whitespace
.850e					_done:
.850e	60		rts		                rts
.850f					help_hexascii_to_value:
.850f	20 d9 84	jsr $84d9	                jsr help_is_decdigit
.8512	90 05		bcc $8519	                bcc _see_if_letter
.8514	38		sec		                sec
.8515	e9 30		sbc #$30	                sbc #'0'
.8517	80 0f		bra $8528	                bra _done
.8519					_see_if_letter:
.8519	c9 41		cmp #$41	                cmp #'A'        ; lower than 'A' can't be right
.851b	90 17		bcc $8534	                bcc _error
.851d	c9 67		cmp #$67	                cmp #'g'        ; 'g' or above can't be right
.851f	b0 13		bcs $8534	                bcs _error
.8521	c9 61		cmp #$61	                cmp #'a'
.8523	90 06		bcc $852b	                bcc _uppercase
.8525	38		sec		                sec
.8526	e9 47		sbc #$47	                sbc #71         ; moves 'a' to 10 ($0A)
.8528					_done:
.8528	29 0f		and #$0f	                and #$0F        ; paranoid
.852a	60		rts		                rts
.852b					_uppercase:
.852b	c9 47		cmp #$47	                cmp #'G'
.852d	b0 05		bcs $8534	                bcs _error
.852f	38		sec		                sec
.8530	e9 37		sbc #$37	                sbc #55         ; moves 'A' to 10 ($0A)
.8532	80 f4		bra $8528	                bra _done
.8534					_error:
.8534	a9 80		lda #$80	                lda #$80
.8536	60		rts		                rts
.8537					help_walk_init:
.8537	84 1f		sty $1f		                sty walk_curr           ; LSB
.8539	85 20		sta $20		                sta walk_curr+1         ; MSB
.853b	80 10		bra $854d	                bra help_walk_common
.853d					help_walk_next:
.853d	b2 1f		lda ($1f)	                lda (walk_curr)
.853f	48		pha		                pha
.8540	a0 01		ldy #$01	                ldy #1
.8542	b1 1f		lda ($1f),y	                lda (walk_curr),y       ; MSB
.8544	29 0f		and #$0f	                and #$0F                ; mask the pair tag
.8546	05 15		ora $15		                ora rsn_ast             ; replace by nibble for the AST
.8548	85 20		sta $20		                sta walk_curr+1
.854a	68		pla		                pla
.854b	85 1f		sta $1f		                sta walk_curr           ; LSB
.854d					help_walk_common:
.854d	b2 1f		lda ($1f)	                lda (walk_curr)
.854f	85 23		sta $23		                sta walk_cdr            ; LSB
.8551	a0 01		ldy #$01	                ldy #1
.8553	b1 1f		lda ($1f),y	                lda (walk_curr),y
.8555	85 24		sta $24		                sta walk_cdr+1          ; MSB
.8557	c8		iny		                iny
.8558	18		clc		                clc                     ; default is not last pair
.8559	05 23		ora $23		                ora walk_cdr            ; LSB
.855b	d0 01		bne $855e	                bne _store_car
.855d	38		sec		                sec                     ; last pair, mark by setting carry flag
.855e					_store_car:
.855e	b1 1f		lda ($1f),y	                lda (walk_curr),y       ; LSB
.8560	85 21		sta $21		                sta walk_car
.8562	48		pha		                pha                     ; We return this later in Y
.8563	c8		iny		                iny
.8564	b1 1f		lda ($1f),y	                lda (walk_curr),y       ; MSB
.8566	85 22		sta $22		                sta walk_car+1
.8568	7a		ply		                ply
.8569	60		rts		                rts

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../primitive-procedures.asm

.856a					proc_apply:
.856a					proc_exit:
.856a	a9 0c		lda #$0c	        lda #str_exit_kill              ; "Kill Scheme (y or n)?"
.856c	20 b7 84	jsr $84b7	        jsr help_print_string_no_lf
.856f	20 b4 84	jsr $84b4	        jsr help_key_a
.8572	c9 79		cmp #$79	        cmp #'y'                        ; only "y" ends
.8574	f0 03		beq $8579	        beq _done
.8576	4c d1 83	jmp $83d1	        jmp eval_next           ; TODO or eval_done?
.8579					_done:
.8579	4c 88 84	jmp $8488	        jmp repl_quit
.857c					proc_quote:
.857c					proc_table_lsb:
>857c	6a 7c 6a			        .byte <proc_apply, <proc_quote, <proc_exit
.857f					proc_table_msb:
>857f	85 85 85			        .byte >proc_apply, >proc_quote, >proc_exit
.8582					proc_char_whitespace_p:
.8582					proc_newline:
.8582					proc_display:
.8582					proc_read:
.8582					proc_read_char:
.8582					proc_read_line:
.8582					proc_write_char:

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../compound-procedures.asm


;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../debug.asm

.8582					debug_dump_input:
.8582	20 af 84	jsr $84af	                jsr help_emit_lf
.8585	a9 03		lda #$03	                lda #strd_dump_input            ; "Input: "
.8587	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.858a	a2 00		ldx #$00	                ldx #0
.858c					-
.858c	bd 00 02	lda $0200,x	                lda cib,x
.858f	f0 0b		beq $859c	                beq _done
.8591	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.8594	e8		inx		                inx
.8595	a9 20		lda #$20	                lda #' '
.8597	20 b1 84	jsr $84b1	                jsr help_emit_a
.859a	80 f0		bra $858c	                bra -
.859c					_done:
.859c	4c 98 84	jmp $8498	                jmp help_byte_to_ascii          ; JSR/RTS
.859f					debug_dump_token:
.859f	20 af 84	jsr $84af	                jsr help_emit_lf
.85a2	a9 00		lda #$00	                lda #strd_dump_token            ; "Token: "
.85a4	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.85a7	a2 00		ldx #$00	                ldx #0
.85a9					-
.85a9	bd 00 03	lda $0300,x	                lda tkb,x
.85ac	c9 00		cmp #$00	                cmp #T_END
.85ae	f0 0d		beq $85bd	                beq _done
.85b0	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.85b3	e8		inx		                inx
.85b4	a9 20		lda #$20	                lda #' '
.85b6	20 b1 84	jsr $84b1	                jsr help_emit_a
.85b9	e4 13		cpx $13		                cpx tkbp
.85bb	d0 ec		bne $85a9	                bne -
.85bd					_done:
.85bd	4c 98 84	jmp $8498	                jmp help_byte_to_ascii          ; JSR/RTS
.85c0					debug_dump_hp:
.85c0	20 af 84	jsr $84af	                jsr help_emit_lf
.85c3	a9 02		lda #$02	                lda #strd_dump_hp               ; "Heap pointer: "
.85c5	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.85c8	a5 19		lda $19		                lda hp_ast+1
.85ca	20 98 84	jsr $8498	                jsr help_byte_to_ascii
.85cd	a5 18		lda $18		                lda hp_ast
.85cf	4c 98 84	jmp $8498	                jmp help_byte_to_ascii          ; JSR/RTS
.85d2					debug_dump_ast:
.85d2	20 af 84	jsr $84af	                jsr help_emit_lf
.85d5	a9 01		lda #$01	                lda #strd_dump_ast              ; "AST root: "
.85d7	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.85da	a5 15		lda $15		                lda rsn_ast             ; RAM segment nibble
.85dc	48		pha		                pha                     ; save MSB
.85dd	20 98 84	jsr $8498	                jsr help_byte_to_ascii  ; print MSB
.85e0	a0 02		ldy #$02	                ldy #2                  ; By definition
.85e2	98		tya		                tya
.85e3	20 98 84	jsr $8498	                jsr help_byte_to_ascii  ; print LSB
.85e6	68		pla		                pla                     ; get MSB back
.85e7	20 37 85	jsr $8537	                jsr help_walk_init
.85ea					_debug_dump_ast_loop:
.85ea	08		php		                php
.85eb	a9 04		lda #$04	                lda #strd_dump_arrow            ; "--> "
.85ed	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.85f0	a5 24		lda $24		                lda walk_cdr+1
.85f2	20 98 84	jsr $8498	                jsr help_byte_to_ascii          ; MSB
.85f5	a5 23		lda $23		                lda walk_cdr
.85f7	20 98 84	jsr $8498	                jsr help_byte_to_ascii          ; LSB
.85fa	a9 3a		lda #$3a	                lda #':'
.85fc	20 b1 84	jsr $84b1	                jsr help_emit_a
.85ff	a5 22		lda $22		                lda walk_car+1
.8601	20 98 84	jsr $8498	                jsr help_byte_to_ascii          ; MSB
.8604	a5 21		lda $21		                lda walk_car
.8606	20 98 84	jsr $8498	                jsr help_byte_to_ascii          ; LSB
.8609	28		plp		                plp
.860a	b0 05		bcs $8611	                bcs _debug_dump_ast_done
.860c	20 3d 85	jsr $853d	                jsr help_walk_next
.860f	80 d9		bra $85ea	                bra _debug_dump_ast_loop
.8611					_debug_dump_ast_done:
.8611	60		rts		                rts
.8612					debug_emit_a:
.8612	48		pha		                pha
.8613	20 af 84	jsr $84af	                jsr help_emit_lf
.8616	68		pla		                pla
.8617	20 b1 84	jsr $84b1	                jsr help_emit_a
.861a	4c af 84	jmp $84af	                jmp help_emit_lf        ; JSR/RTS
.861d					debug_print_string_no_lf:
.861d	0a		asl a		                asl
.861e	a8		tay		                tay
.861f	b9 9f 86	lda $869f,y	                lda sd_table,y
.8622	85 00		sta $00		                sta tmp0                ; LSB
.8624	c8		iny		                iny
.8625	b9 9f 86	lda $869f,y	                lda sd_table,y
.8628	85 01		sta $01		                sta tmp0+1              ; MSB
.862a					debug_print_common:
.862a	a0 00		ldy #$00	                ldy #0
.862c					_loop:
.862c	b1 00		lda ($00),y	                lda (tmp0),y
.862e	f0 06		beq $8636	                beq _done               ; strings are zero-terminated
.8630	20 b1 84	jsr $84b1	                jsr help_emit_a         ; allows vectoring via output
.8633	c8		iny		                iny
.8634	80 f6		bra $862c	                bra _loop
.8636					_done:
.8636	60		rts		                rts
.8637					debug_print_string:
.8637	20 1d 86	jsr $861d	                jsr debug_print_string_no_lf
.863a	4c af 84	jmp $84af	                jmp help_emit_lf        ; JSR/RTS
=0					strd_dump_token  = 0
=1					strd_dump_ast    = 1
=2					strd_dump_hp     = 2
=3					strd_dump_input  = 3
=4					strd_dump_arrow  = 4
=5					strd_dump_strtbl = 5
=6					strd_dump_str    = 6
>863d	54 6f 6b 65 6e 20 42 75		s_dump_token:   .null   "Token Buffer: "
>8645	66 66 65 72 3a 20 00
>864c	41 53 54 20 72 6f 6f 74		s_dump_ast:     .null   "AST root: "
>8654	3a 20 00
>8657	41 53 54 20 68 65 61 70		s_dump_hp:      .null   "AST heap pointer: "
>865f	20 70 6f 69 6e 74 65 72 3a 20 00
>866a	49 6e 70 75 74 20 42 75		s_dump_input:   .null   "Input Buffer: "
>8672	66 66 65 72 3a 20 00
>8679	20 2d 2d 3e 20 00		s_dump_arrow:   .null   " --> "
>867f	53 74 72 69 6e 67 20 74		s_dump_strtbl:  .null   "String table: "
>8687	61 62 6c 65 3a 20 00
>868e	53 74 72 69 6e 67 20 70		s_dump_str:     .null   "String pointer: "
>8696	6f 69 6e 74 65 72 3a 20 00
.869f					sd_table:
>869f	3d 86 4c 86 57 86 6a 86		        .word s_dump_token, s_dump_ast, s_dump_hp, s_dump_input    ; 0-3
>86a7	79 86 7f 86 8e 86		        .word s_dump_arrow, s_dump_strtbl, s_dump_str              ; 4-7

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../definitions.asm

=$03					        AscCC   = $03  ; break (CTRL-c)
=$07					        AscBELL = $07  ; bell sound
=$08					        AscBS   = $08  ; backspace
=$0a					        AscLF   = $0a  ; line feed
=$0d					        AscCR   = $0d  ; carriage return
=$1b					        AscESC  = $1b  ; escape
=$20					        AscSP   = $20  ; space
=$7f					        AscDEL  = $7f  ; delete (CTRL-h)
>0000					tmp0:    .word ?     ; temporary storage, eg printing
>0002					tmp1:    .word ?     ; temporary storage
>0004					tmp2:    .word ?     ; temporary storage
>0006					output:  .word ?     ; output port, addr of routine
>0008					input:   .word ?     ; input port, addr of routine
>000a					jump:    .word ?     ; target for indirect jumps, used by evaluator
>000c					input_f  .byte ?     ; input flag for Reader, see details there
>000d					ciblen:  .word ?     ; current size of input buffer
>000f					cibp:    .word ?     ; index of current char in input buffer
>0011					tkblen:  .word ?     ; current size of the token buffer
>0013					tkbp:    .word ?     ; index of current token in token buffer
>0015					rsn_ast  .byte ?     ; RAM segment nibble for AST segment (default 1)
>0016					astp     .word ?     ; pointer to current entry in AST
>0018					hp_ast   .word ?     ; next free byte in AST RAM segment
>001a					rsn_str  .byte ?     ; RAM segment nibble for strings (default 2)
>001b					strp     .word ?     ; pointer to current entry in string table
>001d					hp_str   .word ?     ; next free byte in string RAM segment
>001f					walk_curr   .word ?  ; Pointer (addr) to current pair in AST
>0021					walk_car    .word ?  ; Contents of current pair's car field
>0023					walk_cdr    .word ?  ; Contents of current pair's cdr field
>0200					cib:    .fill cib_size          ; current input buffer
>0300					tkb:    .fill tkb_size          ; token buffer
>0400					heap:   .fill heap_size         ; RAM available for heap
=$00					OT_META         = $00   ; used for the empty list and terminators
=$10					OT_BOOL         = $10   ; used for #t and #f; immediate
=$20					OT_FIXNUM       = $20   ; used for fixed numbers; immediate
=$30					OT_BIGNUM       = $30   ; reserved for bignum
=$40					OT_CHAR         = $40   ; reserved for chars; immediate
=$50					OT_STRING       = $50   ; used for strings; interned
=$60					ot_undefined_06 = $60
=$70					ot_undefined_07 = $70
=$80					OT_PAIR         = $80   ; used for pairs
=$90					ot_undefined_09 = $90
=$a0					ot_undefined_0a = $a0
=$b0					ot_undefined_0b = $b0
=$c0					ot_undefined_0c = $c0
=$d0					ot_undefined_0d = $d0
=$e0					ot_undefined_0e = $e0
=$f0					OT_PROC         = $f0   ; used for built-in procedures

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../headers.asm

.86ad					h_newline:
>86ad	00 00				        .addr 0000              ; end of header list
>86af	82 85				        .addr proc_newline
>86b1	07				        .byte 7
>86b2	6e 65 77 6c 69 6e 65		        .text "newline"

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../strings.asm

=0					str_unbound    = 0
=1					str_unspec     = 1
=2					str_true       = 2
=3					str_false      = 3
=4					str_bad_token  = 4
=5					str_bad_object = 5
=6					str_bad_number = 6
=7					str_bad_radix  = 7
=8					str_cant_yet   = 8      ; TODO temp during development
=9					str_end_input  = 9
=10					str_chant      = 10
=11					str_prompt     = 11
=12					str_exit_kill  = 12
.86b9					string_table:
>86b9	d3 86 e7 86 01 87 04 87		        .word s_unbound, s_unspec, s_true, s_false      ; 0-3
>86c1	07 87 1b 87 36 87 4c 87		        .word s_bad_token, s_bad_object, s_bad_number, s_bad_radix   ; 4-7
>86c9	60 87 79 87 96 87 ca 87		        .word s_cant_yet, s_end_input, s_chant, s_prompt             ; 8-11
>86d1	cd 87				        .word s_exit_kill                                            ; 12-15
>86d3	3b 55 6e 62 6f 75 6e 64		s_unbound:      .null   ";Unbound variable: "           ; REPL input error
>86db	20 76 61 72 69 61 62 6c 65 3a 20 00
>86e7	3b 55 6e 73 70 65 63 69		s_unspec:       .null   ";Unspecified return value"     ; used eg with (display)
>86ef	66 69 65 64 20 72 65 74 75 72 6e 20 76 61 6c 75
>86ff	65 00
>8701	23 74 00			s_true:         .null   "#t"
>8704	23 66 00			s_false:        .null   "#f"
>8707	50 41 4e 49 43 3a 20 42		s_bad_token:    .null   "PANIC: Bad token: $"           ; from parser
>870f	61 64 20 74 6f 6b 65 6e 3a 20 24 00
>871b	50 41 4e 49 43 3a 20 42		s_bad_object:   .null   "PANIC: Bad object in AST: "    ; from printer
>8723	61 64 20 6f 62 6a 65 63 74 20 69 6e 20 41 53 54
>8733	3a 20 00
>8736	3b 49 6c 6c 2d 66 6f 72		s_bad_number:   .null   ";Ill-formed number: $"         ; from lexer
>873e	6d 65 64 20 6e 75 6d 62 65 72 3a 20 24 00
>874c	50 41 4e 49 43 3a 20 42		s_bad_radix:    .null   "PANIC: Bad radix: $"           ; from parser
>8754	61 64 20 72 61 64 69 78 3a 20 24 00
>8760	41 4c 50 48 41 3a 20 43		s_cant_yet:     .null   "ALPHA: Can't do that yet"      ; from parser
>8768	61 6e 27 74 20 64 6f 20 74 68 61 74 20 79 65 74
>8778	00
>8779	45 6e 64 20 6f 66 20 69		s_end_input:    .null   "End of input stream reached."  ; from reader
>8781	6e 70 75 74 20 73 74 72 65 61 6d 20 72 65 61 63
>8791	68 65 64 2e 00
>8796	50 68 27 6e 67 6c 75 69		s_chant:        .null   "Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn."
>879e	20 6d 67 6c 77 27 6e 61 66 68 20 43 74 68 75 6c
>87ae	68 75 20 52 27 6c 79 65 68 20 77 67 61 68 27 6e
>87be	61 67 6c 20 66 68 74 61 67 6e 2e 00
>87ca	3e 20 00			s_prompt:       .null   "> "
>87cd	4b 69 6c 6c 20 53 63 68		s_exit_kill:    .null   "Kill Scheme (y or n)? "       ; from proc_exit
>87d5	65 6d 65 20 28 79 20 6f 72 20 6e 29 3f 20 00
>87e4	21 24 25 26 2a 2b 2d 2e		s_extended:     .null "!$%&*+-./:<=>?@^_~"
>87ec	2f 3a 3c 3d 3e 3f 40 5e 5f 7e 00

;******  Return to file: platforms/platform-py65mon.asm

>f000					.fill io_size                           ; Save space for the py65mon I/O
.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp cthulhu
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_quit:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	43 74 68 75 6c 68 75 20		        .null "Cthulhu Scheme default kernel for py65mon (13. Apr 2020)", Asclf
>f034	53 63 68 65 6d 65 20 64 65 66 61 75 6c 74 20 6b
>f044	65 72 6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f
>f054	6e 20 28 31 33 2e 20 41 70 72 20 32 30 32 30 29
>f064	0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
