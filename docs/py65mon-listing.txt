
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output cthulhu-py65mon.bin platforms/platform-py65mon.asm
; Sun Apr 12 14:44:41 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platforms/platform-py65mon.asm

=true					DEBUG = true
=false					OCTAL = false
=$0000					ram_start = $0000       ; Start of RAM. Must contain the Zero Page
=$8000					ram_size  = $8000       ; assumes 32 KiB of RAM
=$0000					zp_start  = $0000       ; start of zero page,
=$80					zp_size   = $80         ; max bytes allowed in Zero Page
=$0200					buffers_start   = $0200         ; start of the buffer RAM area
=$100					cib_size        = $100          ; size of the input buffer, used by reader
=$100					tkb_size        = $100          ; size of the token buffer, used by lexer
=31744					heap_size       = ram_size - ($200+cib_size+tkb_size)
=$f000					io_start = $f000
=$10					io_size  = $10
=$8000					rom_start = $8000                       ; $8000 by default
=28672					rom_size = io_start - rom_start         ; $f000 - $8000 = $7000 (28 KiB)
=$fffa					vectors_start = $fffa
=$ffff					max_address   = $ffff

;******  Processing file: platforms/../cthulhu.asm

.8000					cthulhu:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 06		sta $06		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 07		sta $07		                sta output+1
.8009	a9 00		lda #$00	                lda <#heap
.800b	85 12		sta $12		                sta hp
.800d	a9 04		lda #$04	                lda >#heap
.800f	85 13		sta $13		                sta hp+1
.8011	64 14		stz $14		                stz symtbl
.8013	64 15		stz $15		                stz symtbl+1
.8015	64 16		stz $16		                stz strtbl
.8017	64 17		stz $17		                stz strtbl+1
.8019	64 18		stz $18		                stz bnmtbl
.801b	64 19		stz $19		                stz bnmtbl+1
.801d	64 1a		stz $1a		                stz ast
.801f	64 1b		stz $1b		                stz ast+1
.8021	a9 21		lda #$21	                lda #<kernel_getc
.8023	85 08		sta $08		                sta input
.8025	a9 f0		lda #$f0	                lda #>kernel_putc
.8027	85 09		sta $09		                sta input+1
.8029					repl:
.8029	64 0a		stz $0a		                stz ciblen
.802b	64 0b		stz $0b		                stz ciblen+1
.802d					repl_read:
.802d	a0 00		ldy #$00	                ldy #0
.802f	a9 3e		lda #$3e	                lda #'>'
.8031	20 47 83	jsr $8347	                jsr help_emit_a
.8034	a9 20		lda #$20	                lda #' '
.8036	20 47 83	jsr $8347	                jsr help_emit_a
.8039					repl_read_loop:
.8039	20 4a 83	jsr $834a	                jsr help_key_a
.803c	c9 0a		cmp #$0a	                cmp #AscLF
.803e	f0 17		beq $8057	                beq repl_read_eol
.8040	c9 0d		cmp #$0d	                cmp #AscCR
.8042	f0 13		beq $8057	                beq repl_read_eol
.8044	c9 08		cmp #$08	                cmp #AscBS
.8046	f0 1b		beq $8063	                beq repl_read_backspace
.8048	c9 7f		cmp #$7f	                cmp #AscDEL             ; (CTRL-h)
.804a	f0 17		beq $8063	                beq repl_read_backspace
.804c	99 00 02	sta $0200,y	                sta cib,y
.804f	c8		iny		                iny
.8050	20 47 83	jsr $8347	                jsr help_emit_a
.8053	c4 ff		cpy $ff		                cpy cib_size-1        ; reached character limit?
.8055	d0 e2		bne $8039	                bne repl_read_loop    ; fall thru if buffer limit reached
.8057					repl_read_eol:
.8057					repl_read_buffer_full:
.8057	84 0a		sty $0a		                sty ciblen      ; Y contains number of chars accepted already
.8059	a9 00		lda #$00	                lda #0
.805b	85 0b		sta $0b		                sta ciblen+1    ; we only accept 256 chars
.805d	99 00 02	sta $0200,y	                sta cib,y
.8060	4c 7f 80	jmp $807f	                jmp lexer
.8063					repl_read_backspace:
.8063	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8065	d0 06		bne $806d	                bne +
.8067	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8069	20 47 83	jsr $8347	                jsr help_emit_a
.806c	c8		iny		                iny
.806d					+
.806d	88		dey		                dey
.806e	a9 08		lda #$08	                lda #AscBS      ; move back one
.8070	20 47 83	jsr $8347	                jsr help_emit_a
.8073	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8075	20 47 83	jsr $8347	                jsr help_emit_a
.8078	a9 08		lda #$08	                lda #AscBS      ; move back over space
.807a	20 47 83	jsr $8347	                jsr help_emit_a
.807d	80 ba		bra $8039	                bra repl_read_loop

;******  Processing file: platforms/../lexer.asm

.807f					lexer:
.807f	20 c0 83	jsr $83c0	                jsr debug_dump_input
.8082	a0 00		ldy #$00	                ldy #0
.8084	64 0c		stz $0c		                stz cibp
.8086	64 0d		stz $0d		                stz cibp+1      ; MSB currently unused
.8088	64 10		stz $10		                stz tkbp
.808a	64 11		stz $11		                stz tkbp+1      ; MSB currently unused
.808c					lexer_loop:
.808c	b9 00 02	lda $0200,y	                lda cib,y
.808f	20 81 83	jsr $8381	                jsr help_is_whitespace
.8092	90 03		bcc $8097	                bcc _not_whitespace
.8094	4c 52 81	jmp $8152	                jmp lexer_next
.8097					_not_whitespace:
.8097					_test_parens:
.8097					_test_done:
.8097	d0 03		bne $809c	                bne _not_done
.8099	4c 5a 81	jmp $815a	                jmp lexer_end_of_input          ; not the same as lexer_done
.809c					_not_done:
.809c	c9 23		cmp #$23	                cmp #'#'
.809e	f0 03		beq $80a3	                beq _got_sharp
.80a0	4c 40 81	jmp $8140	                jmp lexer_not_sharp             ; too far for branch
.80a3					_got_sharp:
.80a3	c8		iny		                iny
.80a4	b9 00 02	lda $0200,y	                lda cib,y
.80a7	c9 74		cmp #$74	                cmp #'t'                ; We're optimists so we check for true first
.80a9	d0 08		bne $80b3	                bne _not_true
.80ab	a9 10		lda #$10	                lda #T_TRUE
.80ad	20 62 81	jsr $8162	                jsr lexer_add_token
.80b0	4c 52 81	jmp $8152	                jmp lexer_next
.80b3					_not_true:
.80b3	c9 66		cmp #$66	                cmp #'f'
.80b5	d0 08		bne $80bf	                bne _not_false
.80b7	a9 11		lda #$11	                lda #T_FALSE
.80b9	20 62 81	jsr $8162	                jsr lexer_add_token
.80bc	4c 52 81	jmp $8152	                jmp lexer_next
.80bf					_not_false:
.80bf	c9 5c		cmp #$5c	                cmp #'\'
.80c1	d0 00		bne $80c3	                bne _no_backslash
.80c3					_not_single_char:
.80c3					_not_named_char:
.80c3					_no_backslash:
.80c3					_not_vector:
.80c3	c9 78		cmp #$78	                        cmp #'x'        ; #x is hexadecimal
.80c5	d0 04		bne $80cb	                        bne _not_hexnum
.80c7	a9 10		lda #$10	                        lda #$10        ; Base 16
.80c9	80 13		bra $80de	                        bra lexer_got_number
.80cb					_not_hexnum:
.80cb	c9 62		cmp #$62	                        cmp #'b'        ; #b is binary
.80cd	d0 04		bne $80d3	                        bne _not_binnum
.80cf	a9 02		lda #$02	                        lda #$02        ; Base 2
.80d1	80 0b		bra $80de	                        bra lexer_got_number
.80d3					_not_binnum:
.80d3	c9 64		cmp #$64	                        cmp #'d'        ; #d is explicit decimal
.80d5	d0 04		bne $80db	                        bne _illegal_radix
.80d7	a9 0a		lda #$0a	                        lda #$0A        ; Base 10
.80d9	80 03		bra $80de	                        bra lexer_got_number
.80db					_illegal_radix:
.80db	4c 38 81	jmp $8138	                        jmp lexer_illegal_radix
.80de					lexer_got_number:
.80de	48		pha		                        pha                     ; Save the radix for the moment
.80df	a9 12		lda #$12	                        lda #T_NUM_START
.80e1	20 62 81	jsr $8162	                        jsr lexer_add_token
.80e4	68		pla		                        pla
.80e5	20 62 81	jsr $8162	                        jsr lexer_add_token
.80e8	a6 10		ldx $10		                        ldx tkbp        ; get index of where length will be
.80ea	86 00		stx $00		                        stx tmp0
.80ec	a9 00		lda #$00	                        lda #0          ; dummy length value
.80ee	20 62 81	jsr $8162	                        jsr lexer_add_token
.80f1	c8		iny		                        iny             ; Y is still the input buffer index
.80f2	b9 00 02	lda $0200,y	                        lda cib,y
.80f5	a2 00		ldx #$00	                        ldx #0          ; X counts length of string
.80f7	c9 2d		cmp #$2d	                        cmp #'-'
.80f9	d0 09		bne $8104	                        bne _check_for_plus
.80fb	a9 ff		lda #$ff	                        lda #T_MINUS
.80fd	20 62 81	jsr $8162	                        jsr lexer_add_token
.8100	c8		iny		                        iny             ; skip minus character
.8101	e8		inx		                        inx             ; string now has length of 1
.8102	80 0b		bra $810f	                        bra _sign_done
.8104					_check_for_plus:
.8104	c9 2b		cmp #$2b	                        cmp #'+'
.8106	d0 01		bne $8109	                        bne _default_plus
.8108	c8		iny		                        iny
.8109					_default_plus:
.8109	a9 ee		lda #$ee	                        lda #T_PLUS
.810b	20 62 81	jsr $8162	                        jsr lexer_add_token
.810e	e8		inx		                        inx             ; string now has length of 1
.810f					_sign_done:
.810f	b9 00 02	lda $0200,y	                        lda cib,y
.8112	f0 24		beq $8138	                        beq lexer_terminator_too_early  ; 00 terminates input
.8114	20 7b 83	jsr $837b	                        jsr help_is_delimiter
.8117	b0 1f		bcs $8138	                        bcs lexer_delimiter_too_early
.8119					_number_loop:
.8119	20 62 81	jsr $8162	                        jsr lexer_add_token
.811c	e8		inx		                        inx             ; String one character longer
.811d	c8		iny		                        iny             ; Next character
.811e	b9 00 02	lda $0200,y	                        lda cib,y
.8121	f0 07		beq $812a	                        beq _legal_terminator
.8123	20 7b 83	jsr $837b	                        jsr help_is_delimiter
.8126	b0 02		bcs $812a	                        bcs _number_done
.8128	80 ef		bra $8119	                        bra _number_loop
.812a					_legal_terminator:
.812a					_number_done:
.812a	a9 82		lda #$82	                        lda #T_NUM_END
.812c	20 62 81	jsr $8162	                        jsr lexer_add_token
.812f	8a		txa		                        txa             ; number of chars was in X
.8130	a6 00		ldx $00		                        ldx tmp0        ; index of length byte in token stream
.8132	9d 00 03	sta $0300,x	                        sta tkb,x
.8135	4c 53 81	jmp $8153	                        jmp lexer_next_same_char
.8138					lexer_illegal_radix:
.8138					lexer_terminator_too_early:
.8138					lexer_delimiter_too_early:
.8138	a9 06		lda #$06	                lda #str_bad_number
.813a	20 67 83	jsr $8367	                jsr help_print_string
.813d	4c 29 80	jmp $8029	                jmp repl
.8140					lexer_not_octnum
.8140					lexer_not_sharp:
.8140					_not_decnum:
.8140					_not_string:
.8140					lexer_error:
.8140	48		pha		                pha
.8141	a9 00		lda #$00	                lda #str_unbound
.8143	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.8146	68		pla		                pla
.8147	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.814a	a9 0a		lda #$0a	                lda #AscLF
.814c	20 47 83	jsr $8347	                jsr help_emit_a
.814f	4c 29 80	jmp $8029	                jmp repl
.8152					lexer_next:
.8152	c8		iny		                iny
.8153					lexer_next_same_char:
.8153	c4 0a		cpy $0a		                cpy ciblen
.8155	f0 03		beq $815a	                beq lexer_end_of_input
.8157	4c 8c 80	jmp $808c	                jmp lexer_loop
.815a					lexer_end_of_input:
.815a	a9 00		lda #$00	                lda #T_END
.815c	20 62 81	jsr $8162	                jsr lexer_add_token
.815f	4c 6d 81	jmp $816d	                jmp lexer_done
.8162					lexer_add_token:
.8162	5a		phy		                phy             ; Could also store in cibp
.8163	a4 10		ldy $10		                ldy tkbp
.8165	99 00 03	sta $0300,y	                sta tkb,y       ; LSB is in A
.8168	c8		iny		                iny
.8169	84 10		sty $10		                sty tkbp
.816b	7a		ply		                ply
.816c	60		rts		                rts
=$00					T_END           = $00
=$01					T_PAREN_OPEN    = $01   ; '('
=$02					T_PAREN_CLOSED  = $02   ; ')'
=$03					T_SHARP         = $03   ; '#' - note '#f', '#t' and others are precprocessed
=$10					T_TRUE       = $10   ; '#t'
=$11					T_FALSE      = $11   ; '#f'
=$12					T_NUM_START  = $12   ; Marks beginning of a number sequence
=$82					T_NUM_END    = $82   ; Marks end of a number sequence, see T_NUM_START
=$ee					T_PLUS       = $EE   ; Also used in number token sequence
=$ff					T_MINUS      = $FF   ; Also used in number token sequence
.816d					lexer_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../parser.asm

.816d					parser:
.816d	20 df 83	jsr $83df	                jsr debug_dump_token
.8170	64 1a		stz $1a		                stz ast
.8172	64 1b		stz $1b		                stz ast+1
.8174	64 10		stz $10		                stz tkbp
.8176	64 11		stz $11		                stz tkbp+1      ; fake, currently only using LSB
.8178	a9 1a		lda #$1a	                lda <#ast
.817a	85 1c		sta $1c		                sta astp
.817c	a9 00		lda #$00	                lda >#ast       ; paranoid, MSB always 00 for zero page
.817e	85 1d		sta $1d		                sta astp+1
.8180	a2 ff		ldx #$ff	                ldx #$FF
.8182					parser_loop:
.8182	e8		inx		                inx
.8183	bd 00 03	lda $0300,x	                lda tkb,x
.8186					_end_token:
.8186	c9 00		cmp #$00	                cmp #T_END
.8188	d0 03		bne $818d	                bne _not_end_token
.818a	4c cb 82	jmp $82cb	                jmp parser_done
.818d					_not_end_token:
.818d	c9 10		cmp #$10	                cmp #T_TRUE
.818f	d0 0a		bne $819b	                bne _not_true_token
.8191	a9 ff		lda #$ff	                lda <#OC_TRUE
.8193	a0 1f		ldy #$1f	                ldy >#OC_TRUE
.8195	20 89 82	jsr $8289	                jsr parser_add_object
.8198	4c 82 81	jmp $8182	                jmp parser_loop
.819b					_not_true_token:
.819b	c9 11		cmp #$11	                cmp #T_FALSE
.819d	d0 0a		bne $81a9	                bne _not_false_token
.819f	a9 00		lda #$00	                lda <#OC_FALSE
.81a1	a0 10		ldy #$10	                ldy >#OC_FALSE
.81a3	20 89 82	jsr $8289	                jsr parser_add_object
.81a6	4c 82 81	jmp $8182	                jmp parser_loop
.81a9					_not_false_token:
.81a9	c9 12		cmp #$12	                cmp #T_NUM_START
.81ab	f0 03		beq $81b0	                beq +
.81ad	4c 67 82	jmp $8267	                jmp parser_not_num              ; Too far for BRA
.81b0					+
.81b0	64 02		stz $02		                stz tmp1
.81b2	64 03		stz $03		                stz tmp1+1
.81b4	e8		inx		                inx                     ; skip over T_NUM_START TOKEN
.81b5	bd 00 03	lda $0300,x	                lda tkb,x
.81b8	85 00		sta $00		                sta tmp0        ; radix
.81ba	e8		inx		                inx
.81bb	bd 00 03	lda $0300,x	                lda tkb,x
.81be	a8		tay		                tay             ; we need the length of the string later ...
.81bf	88		dey		                dey             ; ... but we don't need to include the sign
.81c0	e8		inx		                inx             ; Move to token for sign, T_PLUS or T_MINUS
.81c1	bd 00 03	lda $0300,x	                lda tkb,x
.81c4	85 01		sta $01		                sta tmp0+1      ; Just store it for now
.81c6	e8		inx		                inx
.81c7	a5 00		lda $00		                lda tmp0        ; radix
.81c9	c9 0a		cmp #$0a	                cmp #$0a
.81cb	d0 03		bne $81d0	                bne _not_dec
.81cd	4c 50 82	jmp $8250	                jmp parser_common_fixnum
.81d0					_not_dec:
.81d0	c9 10		cmp #$10	                cmp #$10
.81d2	d0 6e		bne $8242	                bne _not_hex
.81d4	98		tya		                tya
.81d5	c9 04		cmp #$04	                cmp #$04
.81d7	90 03		bcc $81dc	                bcc _dec_fixnum
.81d9	4c 81 82	jmp $8281	                jmp function_not_available
.81dc					_dec_fixnum:
.81dc	bd 00 03	lda $0300,x	                lda tkb,x
.81df	20 98 83	jsr $8398	                jsr help_hexascii_to_value
.81e2	10 03		bpl $81e7	                bpl _legal_first_hex_digit
.81e4	4c 79 82	jmp $8279	                jmp parser_bad_digit
.81e7					_legal_first_hex_digit:
.81e7	85 03		sta $03		                sta tmp1+1      ; MSB, lower nibble
.81e9	e8		inx		                inx
.81ea	bd 00 03	lda $0300,x	                lda tkb,x
.81ed	c9 82		cmp #$82	                cmp #T_NUM_END
.81ef	f0 23		beq $8214	                beq _done_hex
.81f1	20 98 83	jsr $8398	                jsr help_hexascii_to_value
.81f4	10 03		bpl $81f9	                bpl _legal_second_hex_digit
.81f6	4c 79 82	jmp $8279	                jmp parser_bad_digit
.81f9					_legal_second_hex_digit:
.81f9	0a		asl a		                asl
.81fa	0a		asl a		                asl
.81fb	0a		asl a		                asl
.81fc	0a		asl a		                asl
.81fd	05 03		ora $03		                ora tmp1+1      ; MSB, both nibbles
.81ff	85 03		sta $03		                sta tmp1+1
.8201	e8		inx		                inx
.8202	bd 00 03	lda $0300,x	                lda tkb,x
.8205	c9 82		cmp #$82	                cmp #T_NUM_END
.8207	f0 0b		beq $8214	                beq _done_hex
.8209	20 98 83	jsr $8398	                jsr help_hexascii_to_value
.820c	10 03		bpl $8211	                bpl _legal_third_hex_digit
.820e	4c 79 82	jmp $8279	                jmp parser_bad_digit
.8211					_legal_third_hex_digit:
.8211	85 02		sta $02		                sta tmp1        ; LSB, lower nibble, upper is for object tag
.8213	e8		inx		                inx
.8214					_done_hex:
.8214	c0 01		cpy #$01	                cpy #1
.8216	f0 26		beq $823e	                beq _done_hex_shuffle
.8218	c0 02		cpy #$02	                cpy #2
.821a	d0 0e		bne $822a	                bne _shuffle_three_digits
.821c	a5 03		lda $03		                lda tmp1+1      ; $21 for example
.821e	0a		asl a		                asl
.821f	69 80		adc #$80	                adc #$80
.8221	2a		rol a		                rol
.8222	0a		asl a		                asl
.8223	69 80		adc #$80	                adc #$80
.8225	2a		rol a		                rol
.8226	85 03		sta $03		                sta tmp1+1
.8228	80 14		bra $823e	                bra _done_hex_shuffle
.822a					_shuffle_three_digits:
.822a	a5 02		lda $02		                lda tmp1        ; $03
.822c	a8		tay		                tay
.822d	a5 03		lda $03		                lda tmp1+1      ; $21
.822f	29 0f		and #$0f	                and #$0f        ; $01
.8231	85 02		sta $02		                sta tmp1
.8233	a5 03		lda $03		                lda tmp1+1      ; $21
.8235	29 f0		and #$f0	                and #$f0        ; $20
.8237	85 03		sta $03		                sta tmp1+1
.8239	98		tya		                tya             ; $03
.823a	05 03		ora $03		                ora tmp1+1      ; $23
.823c	85 03		sta $03		                sta tmp1+1
.823e					_done_hex_shuffle:
.823e	e8		inx		                inx
.823f	4c 50 82	jmp $8250	                jmp parser_common_fixnum
.8242					_not_hex:
.8242	c9 02		cmp #$02	                cmp #$02
.8244	d0 02		bne $8248	                bne _not_binary
.8246	80 08		bra $8250	                bra parser_common_fixnum
.8248					_not_binary:
.8248					_illegal_radix:
.8248	48		pha		                pha                             ; save the evil radix
.8249	a9 07		lda #$07	                lda #str_bad_radix
.824b	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.824e	80 1d		bra $826d	                bra parser_common_panic         ; prints offending byte and LF
.8250					parser_common_fixnum:
.8250	a9 0a		lda #$0a	                lda #AscLF
.8252	20 47 83	jsr $8347	                jsr help_emit_a
.8255	a5 02		lda $02		                lda tmp1
.8257	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.825a	a5 03		lda $03		                lda tmp1+1
.825c	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.825f	a9 0a		lda #$0a	                lda #AscLF
.8261	20 47 83	jsr $8347	                jsr help_emit_a
.8264					_num_end:
.8264	4c 82 81	jmp $8182	                jmp parser_loop
.8267					parser_not_num:
.8267					paser_bad_token:
.8267	48		pha		                pha                             ; save the evil token
.8268	a9 04		lda #$04	                lda #str_bad_token
.826a	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.826d					parser_common_panic:
.826d	68		pla		                pla
.826e	20 30 83	jsr $8330	                jsr help_byte_to_ascii          ; print bad token as hex number
.8271	a9 0a		lda #$0a	                lda #AscLF
.8273	20 47 83	jsr $8347	                jsr help_emit_a
.8276	4c 29 80	jmp $8029	                jmp repl
.8279					parser_bad_digit:
.8279	48		pha		                pha
.827a	a9 06		lda #$06	                lda #str_bad_number
.827c	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.827f	80 ec		bra $826d	                bra parser_common_panic
.8281					function_not_available:
.8281	a9 08		lda #$08	                lda #str_cant_yet
.8283	20 67 83	jsr $8367	                jsr help_print_string
.8286	4c 29 80	jmp $8029	                jmp repl
.8289					parser_add_object:
.8289	da		phx		                phx             ; save index to token buffer
.828a	5a		phy		                phy             ; save MSB of the object
.828b	48		pha		                pha             ; save LSB of the object
.828c	a5 12		lda $12		                lda hp
.828e	85 00		sta $00		                sta tmp0
.8290	a5 13		lda $13		                lda hp+1
.8292	85 01		sta $01		                sta tmp0+1
.8294	a9 00		lda #$00	                lda <#OC_END
.8296	a0 00		ldy #$00	                ldy #0
.8298	91 12		sta ($12),y	                sta (hp),y
.829a	c8		iny		                iny
.829b	a9 00		lda #$00	                lda >#OC_END
.829d	91 12		sta ($12),y	                sta (hp),y
.829f	c8		iny		                iny
.82a0	68		pla		                pla             ; retrieve LSB
.82a1	91 12		sta ($12),y	                sta (hp),y
.82a3	c8		iny		                iny
.82a4	68		pla		                pla             ; retrieve MSB, was in Y
.82a5	91 12		sta ($12),y	                sta (hp),y
.82a7	c8		iny		                iny
.82a8	a9 00		lda #$00	                lda #0
.82aa	91 12		sta ($12),y	                sta (hp),y
.82ac	c8		iny		                iny
.82ad	91 12		sta ($12),y	                sta (hp),y
.82af	c8		iny		                iny
.82b0	98		tya		                tya
.82b1	18		clc		                clc
.82b2	65 12		adc $12		                adc hp
.82b4	85 12		sta $12		                sta hp
.82b6	90 02		bcc $82ba	                bcc +
.82b8	e6 13		inc $13		                inc hp+1
.82ba					+
.82ba	a5 00		lda $00		                lda tmp0        ; original LSB of hp
.82bc	aa		tax		                tax             ; We'll need it again in a second
.82bd	92 1c		sta ($1c)	                sta (astp)
.82bf	a0 01		ldy #$01	                ldy #1
.82c1	a5 01		lda $01		                lda tmp0+1      ; original MSB of hp
.82c3	91 1c		sta ($1c),y	                sta (astp),y
.82c5	85 1d		sta $1d		                sta astp+1      ; MSB, was tmp0+1
.82c7	86 1c		stx $1c		                stx astp        ; LSB, was tmp0
.82c9	fa		plx		                plx             ; get back index for token buffer
.82ca	60		rts		                rts
=$0000					OC_END   = $0000        ; end of input for AST
=$1fff					OC_TRUE  = $1fff        ; true bool #t, immediate
=$1000					OC_FALSE = $1000        ; false bool #f, immediate
.82cb					parser_done:
.82cb	a9 00		lda #$00	                lda <#OC_END
.82cd	a2 00		ldx #$00	                ldx >#OC_END
.82cf	20 89 82	jsr $8289	                jsr parser_add_object

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../eval.asm

.82d2					eval:
.82d2	20 16 84	jsr $8416	                jsr debug_dump_ast
.82d5	20 02 84	jsr $8402	                jsr debug_dump_hp
.82d8					eval_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../printer.asm

.82d8					printer:
.82d8	a9 0a		lda #$0a	        lda #AscLF
.82da	20 47 83	jsr $8347	        jsr help_emit_a
.82dd	a5 1a		lda $1a		                lda ast
.82df	85 02		sta $02		                sta tmp1
.82e1	a5 1b		lda $1b		                lda ast+1
.82e3	85 03		sta $03		                sta tmp1+1
.82e5					printer_loop:
.82e5	a0 03		ldy #$03	                ldy #3                  ; MSB of the next node entry down ...
.82e7	b1 02		lda ($02),y	                lda (tmp1),y            ; ...  which contains the tag nibble
.82e9	29 f0		and #$f0	                and #$f0                ; mask all but tag nibble
.82eb					_check_for_meta:
.82eb	c9 00		cmp #$00	                cmp #ot_meta
.82ed	d0 07		bne $82f6	                bne _not_meta
.82ef	12 02		ora ($02)	                ora (tmp1)              ; LSB
.82f1	d0 19		bne $830c	                bne printer_error       ; We're in trouble, panic and re-REPL
.82f3	4c 2d 83	jmp $832d	                jmp printer_done
.82f6					_not_meta:
.82f6	c9 10		cmp #$10	                cmp #ot_bool
.82f8	d0 12		bne $830c	                bne _not_bool
.82fa	a0 02		ldy #$02	                ldy #2
.82fc	b1 02		lda ($02),y	                lda (tmp1),y            ; LSB
.82fe	d0 04		bne $8304	                bne _bool_true          ; not a zero means true
.8300	a9 03		lda #$03	                lda #str_false
.8302	80 02		bra $8306	                bra _bool_printer
.8304					_bool_true:
.8304	a9 02		lda #$02	                lda #str_true
.8306					_bool_printer:
.8306	20 67 83	jsr $8367	                jsr help_print_string
.8309	4c 1f 83	jmp $831f	                jmp printer_next
.830c					_not_bool:
.830c					printer_error:
.830c	a5 05		lda $05		                lda str_bad_object
.830e	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.8311	a0 01		ldy #$01	                ldy #1
.8313	b1 02		lda ($02),y	                lda (tmp1),y
.8315	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8318	b2 02		lda ($02)	                lda (tmp1)
.831a	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.831d	80 0e		bra $832d	                bra printer_done
.831f					printer_next:
.831f	b2 02		lda ($02)	                lda (tmp1)              ; LSB of next entry
.8321	aa		tax		                tax
.8322	a0 01		ldy #$01	                ldy #1
.8324	b1 02		lda ($02),y	                lda (tmp1),y            ; MSB of next entry
.8326	85 03		sta $03		                sta tmp1+1
.8328	86 02		stx $02		                stx tmp1
.832a	4c e5 82	jmp $82e5	                jmp printer_loop
.832d					printer_done:

;******  Return to file: platforms/../cthulhu.asm

.832d					repl_done:
.832d	4c 29 80	jmp $8029	                jmp repl

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../helpers.asm

.8330					help_byte_to_ascii:
.8330	48		pha		                pha
.8331	4a		lsr a		                lsr             ; convert high nibble first
.8332	4a		lsr a		                lsr
.8333	4a		lsr a		                lsr
.8334	4a		lsr a		                lsr
.8335	20 39 83	jsr $8339	                jsr help_nibble_to_ascii
.8338	68		pla		                pla
.8339					help_nibble_to_ascii:
.8339	29 0f		and #$0f	                and #$0F
.833b	09 30		ora #$30	                ora #'0'
.833d	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.833f	90 02		bcc $8343	                bcc +
.8341	69 06		adc #$06	                adc #$06
.8343	4c 47 83	jmp $8347	+               jmp help_emit_a       ; JSR/RTS
.8346					help_to_lowercase:
.8346	60		rts		                rts
.8347					help_emit_a:
.8347	6c 06 00	jmp ($0006)	                jmp (output)    ; JSR/RTS
.834a					help_key_a:
.834a	6c 08 00	jmp ($0008)	                jmp (input)             ; JSR/RTS
.834d					help_print_string_no_lf:
.834d	0a		asl a		                asl
.834e	a8		tay		                tay
.834f	b9 f2 84	lda $84f2,y	                lda string_table,y
.8352	85 00		sta $00		                sta tmp0                ; LSB
.8354	c8		iny		                iny
.8355	b9 f2 84	lda $84f2,y	                lda string_table,y
.8358	85 01		sta $01		                sta tmp0+1              ; MSB
.835a					help_print_common:
.835a	a0 00		ldy #$00	                ldy #0
.835c					_loop:
.835c	b1 00		lda ($00),y	                lda (tmp0),y
.835e	f0 06		beq $8366	                beq _done               ; strings are zero-terminated
.8360	20 47 83	jsr $8347	                jsr help_emit_a         ; allows vectoring via output
.8363	c8		iny		                iny
.8364	80 f6		bra $835c	                bra _loop
.8366					_done:
.8366	60		rts		                rts
.8367					help_print_string:
.8367	20 4d 83	jsr $834d	                jsr help_print_string_no_lf
.836a	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.836c	4c 47 83	jmp $8347	                jmp help_emit_a         ; JSR/RTS
.836f					help_is_decdigit:
.836f	c9 30		cmp #$30	                cmp #'0'
.8371	90 07		bcc $837a	                bcc _below_zero         ; A is < '0'
.8373	c9 3a		cmp #$3a	                cmp #':'                ; A is >= ':', which is '9'+1
.8375	b0 02		bcs $8379	                bcs _above_nine
.8377	38		sec		                sec
.8378	60		rts		                rts
.8379					_above_nine:
.8379	18		clc		                clc
.837a					_below_zero:
.837a	60		rts		                rts
.837b					help_is_delimiter:
.837b	20 81 83	jsr $8381	                jsr help_is_whitespace
.837e	b0 00		bcs $8380	                bcs _delimiter_done
.8380					_delimiter_done:
.8380	60		rts		                rts
.8381					help_is_whitespace:
.8381	38		sec		                sec             ; default is whitespace
.8382	c9 20		cmp #$20	                cmp #$20        ; SPACE, assumed to be the most common char
.8384	f0 11		beq $8397	                beq _done
.8386	c9 09		cmp #$09	                cmp #$09        ; TAB, probably the second most common in Scheme
.8388	f0 0d		beq $8397	                beq _done
.838a	c9 0a		cmp #$0a	                cmp #$0A        ; Linefeed, normally ends input but not with Scheme
.838c	f0 09		beq $8397	                beq _done
.838e	c9 0d		cmp #$0d	                cmp #$0D        ; Return, normally ends input but not with Scheme
.8390	f0 05		beq $8397	                beq _done
.8392	c9 0c		cmp #$0c	                cmp #$0C        ; Page, which is strange, but in the standard
.8394	f0 01		beq $8397	                beq _done
.8396	18		clc		                clc             ; If we end up here, it's not whitespace
.8397					_done:
.8397	60		rts		                rts
.8398					help_hexascii_to_value:
.8398	20 6f 83	jsr $836f	                jsr help_is_decdigit
.839b	90 05		bcc $83a2	                bcc _see_if_letter
.839d	38		sec		                sec
.839e	e9 30		sbc #$30	                sbc #'0'
.83a0	80 0f		bra $83b1	                bra _done
.83a2					_see_if_letter:
.83a2	c9 41		cmp #$41	                cmp #'A'        ; lower than 'A' can't be right
.83a4	90 17		bcc $83bd	                bcc _error
.83a6	c9 67		cmp #$67	                cmp #'g'        ; 'g' or above can't be right
.83a8	b0 13		bcs $83bd	                bcs _error
.83aa	c9 61		cmp #$61	                cmp #'a'
.83ac	90 06		bcc $83b4	                bcc _uppercase
.83ae	38		sec		                sec
.83af	e9 47		sbc #$47	                sbc #71         ; moves 'a' to 10 ($0A)
.83b1					_done:
.83b1	29 0f		and #$0f	                and #$0F        ; paranoid
.83b3	60		rts		                rts
.83b4					_uppercase:
.83b4	c9 47		cmp #$47	                cmp #'G'
.83b6	b0 05		bcs $83bd	                bcs _error
.83b8	38		sec		                sec
.83b9	e9 37		sbc #$37	                sbc #55         ; moves 'A' to 10 ($0A)
.83bb	80 f4		bra $83b1	                bra _done
.83bd					_error:
.83bd	a9 80		lda #$80	                lda #$80
.83bf	60		rts		                rts

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../native-procedures.asm

.83c0					proc_char_whitespace_p:
.83c0					proc_newline:
.83c0					proc_display:
.83c0					proc_read:
.83c0					proc_read_char:
.83c0					proc_read_line:
.83c0					proc_write_char:

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../procedures.asm


;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../debug.asm

.83c0					debug_dump_input:
.83c0	a9 0a		lda #$0a	                lda #AscLF
.83c2	20 47 83	jsr $8347	                jsr help_emit_a
.83c5	a9 03		lda #$03	                lda #strd_dump_input            ; "Input: "
.83c7	20 89 84	jsr $8489	                jsr debug_print_string_no_lf
.83ca	a2 00		ldx #$00	                ldx #0
.83cc					-
.83cc	bd 00 02	lda $0200,x	                lda cib,x
.83cf	f0 0b		beq $83dc	                beq _done
.83d1	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.83d4	e8		inx		                inx
.83d5	a9 20		lda #$20	                lda #' '
.83d7	20 47 83	jsr $8347	                jsr help_emit_a
.83da	80 f0		bra $83cc	                bra -
.83dc					_done:
.83dc	4c 30 83	jmp $8330	                jmp help_byte_to_ascii          ; JSR/RTS
.83df					debug_dump_token:
.83df	a9 0a		lda #$0a	                lda #AscLF
.83e1	20 47 83	jsr $8347	                jsr help_emit_a
.83e4	a9 00		lda #$00	                lda #strd_dump_token            ; "Token: "
.83e6	20 89 84	jsr $8489	                jsr debug_print_string_no_lf
.83e9	a2 00		ldx #$00	                ldx #0
.83eb					-
.83eb	bd 00 03	lda $0300,x	                lda tkb,x
.83ee	c9 00		cmp #$00	                cmp #T_END
.83f0	f0 0d		beq $83ff	                beq _done
.83f2	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.83f5	e8		inx		                inx
.83f6	a9 20		lda #$20	                lda #' '
.83f8	20 47 83	jsr $8347	                jsr help_emit_a
.83fb	e4 10		cpx $10		                cpx tkbp
.83fd	d0 ec		bne $83eb	                bne -
.83ff					_done:
.83ff	4c 30 83	jmp $8330	                jmp help_byte_to_ascii          ; JSR/RTS
.8402					debug_dump_hp:
.8402	a9 0a		lda #$0a	                lda #AscLF
.8404	20 47 83	jsr $8347	                jsr help_emit_a
.8407	a9 02		lda #$02	                lda #strd_dump_hp               ; "Heap pointer: "
.8409	20 89 84	jsr $8489	                jsr debug_print_string_no_lf
.840c	a5 13		lda $13		                lda hp+1
.840e	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8411	a5 12		lda $12		                lda hp
.8413	4c 30 83	jmp $8330	                jmp help_byte_to_ascii          ; JSR/RTS
.8416					debug_dump_ast:
.8416	a9 0a		lda #$0a	                lda #AscLF
.8418	20 47 83	jsr $8347	                jsr help_emit_a
.841b	a9 01		lda #$01	                lda #strd_dump_ast              ; "AST: "
.841d	20 89 84	jsr $8489	                jsr debug_print_string_no_lf
.8420	a5 1b		lda $1b		                lda ast+1
.8422	85 03		sta $03		                sta tmp1+1
.8424	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8427	a5 1a		lda $1a		                lda ast
.8429	85 02		sta $02		                sta tmp1
.842b	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.842e					_loop:
.842e	a9 20		lda #$20	                lda #' '
.8430	20 47 83	jsr $8347	                jsr help_emit_a
.8433	a0 01		ldy #$01	                ldy #1
.8435	b1 02		lda ($02),y	                lda (tmp1),y
.8437	85 05		sta $05		                sta tmp2+1
.8439	20 30 83	jsr $8330	                jsr help_byte_to_ascii          ; MSB
.843c	b2 02		lda ($02)	                lda (tmp1)
.843e	85 04		sta $04		                sta tmp2                        ; pointer to next entry, LSB
.8440	20 30 83	jsr $8330	                jsr help_byte_to_ascii          ; LSB
.8443	a9 3a		lda #$3a	                lda #':'
.8445	20 47 83	jsr $8347	                jsr help_emit_a
.8448	a0 03		ldy #$03	                ldy #3
.844a	b1 02		lda ($02),y	                lda (tmp1),y
.844c	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.844f	a0 02		ldy #$02	                ldy #2
.8451	b1 02		lda ($02),y	                lda (tmp1),y
.8453	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8456	a9 3a		lda #$3a	                lda #':'
.8458	20 47 83	jsr $8347	                jsr help_emit_a
.845b	a0 05		ldy #$05	                ldy #5
.845d	b1 02		lda ($02),y	                lda (tmp1),y
.845f	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8462	a0 04		ldy #$04	                ldy #4
.8464	b1 02		lda ($02),y	                lda (tmp1),y
.8466	20 30 83	jsr $8330	                jsr help_byte_to_ascii
.8469	a5 04		lda $04		                lda tmp2
.846b	05 05		ora $05		                ora tmp2+1      ; Cheating: We know that OC_END is 0000
.846d	f0 0a		beq $8479	                beq _done
.846f	a5 04		lda $04		                lda tmp2
.8471	85 02		sta $02		                sta tmp1
.8473	a5 05		lda $05		                lda tmp2+1
.8475	85 03		sta $03		                sta tmp1+1
.8477	80 b5		bra $842e	                bra _loop
.8479					_done:
.8479	60		rts		                rts
.847a					debug_emit_a:
.847a	48		pha		                pha
.847b	a9 0a		lda #$0a	                lda #AscLF
.847d	20 47 83	jsr $8347	                jsr help_emit_a
.8480	68		pla		                pla
.8481	20 47 83	jsr $8347	                jsr help_emit_a
.8484	a9 0a		lda #$0a	                lda #AscLF
.8486	4c 47 83	jmp $8347	                jmp help_emit_a         ; JSR/RTS
.8489					debug_print_string_no_lf:
.8489	0a		asl a		                asl
.848a	a8		tay		                tay
.848b	b9 de 84	lda $84de,y	                lda sd_table,y
.848e	85 00		sta $00		                sta tmp0                ; LSB
.8490	c8		iny		                iny
.8491	b9 de 84	lda $84de,y	                lda sd_table,y
.8494	85 01		sta $01		                sta tmp0+1              ; MSB
.8496					debug_print_common:
.8496	a0 00		ldy #$00	                ldy #0
.8498					_loop:
.8498	b1 00		lda ($00),y	                lda (tmp0),y
.849a	f0 06		beq $84a2	                beq _done               ; strings are zero-terminated
.849c	20 47 83	jsr $8347	                jsr help_emit_a         ; allows vectoring via output
.849f	c8		iny		                iny
.84a0	80 f6		bra $8498	                bra _loop
.84a2					_done:
.84a2	60		rts		                rts
.84a3					debug_print_string:
.84a3	20 89 84	jsr $8489	                jsr debug_print_string_no_lf
.84a6	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.84a8	4c 47 83	jmp $8347	                jmp help_emit_a         ; JSR/RTS
=0					strd_dump_token = 0
=1					strd_dump_ast   = 1
=2					strd_dump_hp    = 2
=3					strd_dump_input = 3
>84ab	54 6f 6b 65 6e 20 42 75		s_dump_token:   .null   "Token Buffer: "
>84b3	66 66 65 72 3a 20 00
>84ba	41 53 54 3a 20 00		s_dump_ast:     .null   "AST: "
>84c0	48 65 61 70 20 70 6f 69		s_dump_hp:      .null   "Heap pointer: "
>84c8	6e 74 65 72 3a 20 00
>84cf	49 6e 70 75 74 20 42 75		s_dump_input:   .null   "Input Buffer: "
>84d7	66 66 65 72 3a 20 00
.84de					sd_table:
>84de	ab 84 ba 84 c0 84 cf 84		        .word s_dump_token, s_dump_ast, s_dump_hp, s_dump_input      ; 0-3

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../definitions.asm

=$03					        AscCC   = $03  ; break (CTRL-c)
=$07					        AscBELL = $07  ; bell sound
=$08					        AscBS   = $08  ; backspace
=$0a					        AscLF   = $0a  ; line feed
=$0d					        AscCR   = $0d  ; carriage return
=$1b					        AscESC  = $1b  ; escape
=$20					        AscSP   = $20  ; space
=$7f					        AscDEL  = $7f  ; delete (CTRL-h)
>0000					tmp0:    .word ?     ; temporary storage, eg printing
>0002					tmp1:    .word ?     ; temporary storage
>0004					tmp2:    .word ?     ; temporary storage
>0006					output:  .word ?     ; output port, addr of routine
>0008					input:   .word ?     ; input port, addr of routine
>000a					ciblen:  .word ?     ; current size of input buffer
>000c					cibp:    .word ?     ; index of current char in input buffer
>000e					tkblen:  .word ?     ; current size of the token buffer
>0010					tkbp:    .word ?     ; index of current token in token buffer
>0012					hp:      .word ?     ; pointer to next free heap entry
>0014					symtbl:  .word ?     ; pointer to first entry in symbol table in heap
>0016					strtbl:  .word ?     ; pointer to first entry in string table in heap
>0018					bnmtbl:  .word ?     ; pointer to first entry in bignum table in heap
>001a					ast      .word ?     ; pointer to root of Abstract Systax Tree (AST)
>001c					astp     .word ?     ; pointer to current entry in AST
>0200					cib:    .fill cib_size          ; current input buffer
>0300					tkb:    .fill tkb_size          ; token buffer
>0400					heap:   .fill heap_size         ; RAM available for heap
=$00					ot_meta         = $00    ; used for end of input and other markers
=$10					ot_bool         = $10    ; used for #t and #f; immediate
=$20					ot_fixnum       = $20    ; used for fixed numbers; immediate
=$30					ot_bignum       = $30    ; used for bignum
=$40					ot_char         = $40    ; used for chars; immediate
=$50					ot_undefined_05 = $50
=$60					ot_undefined_06 = $60
=$70					ot_undefined_07 = $70
=$80					ot_undefined_08 = $80
=$90					ot_undefined_09 = $90
=$a0					ot_undefined_0a = $a0
=$b0					ot_undefined_0b = $b0
=$c0					ot_undefined_0c = $c0
=$d0					ot_undefined_0d = $d0
=$e0					ot_undefined_0e = $e0
=$f0					ot_undefined_0f = $f0

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../headers.asm

.84e6					h_newline:
>84e6	00 00				        .addr 0000              ; end of header list
>84e8	c0 83				        .addr proc_newline
>84ea	07				        .byte 7
>84eb	6e 65 77 6c 69 6e 65		        .text "newline"

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../strings.asm

=0					str_unbound    = 0
=1					str_unspec     = 1
=2					str_true       = 2
=3					str_false      = 3
=4					str_bad_token  = 4
=5					str_bad_object = 5
=6					str_bad_number = 6
=7					str_bad_radix  = 7
=8					str_cant_yet   = 8      ; TODO temp during development
.84f2					string_table:
>84f2	04 85 18 85 32 85 35 85		        .word s_unbound, s_unspec, s_true, s_false      ; 0-3
>84fa	38 85 4c 85 67 85 7a 85		        .word s_bad_token, s_bad_object, s_bad_number, s_bad_radix   ; 4-7
>8502	8e 85				        .word s_cant_yet                                             ; 8-11
>8504	3b 55 6e 62 6f 75 6e 64		s_unbound:      .null   ";Unbound variable: "           ; REPL input error
>850c	20 76 61 72 69 61 62 6c 65 3a 20 00
>8518	3b 55 6e 73 70 65 63 69		s_unspec:       .null   ";Unspecified return value"     ; used eg with (display)
>8520	66 69 65 64 20 72 65 74 75 72 6e 20 76 61 6c 75
>8530	65 00
>8532	23 74 00			s_true:         .null   "#t"
>8535	23 66 00			s_false:        .null   "#f"
>8538	50 41 4e 49 43 3a 20 42		s_bad_token:    .null   "PANIC: Bad token: $"           ; from parser
>8540	61 64 20 74 6f 6b 65 6e 3a 20 24 00
>854c	50 41 4e 49 43 3a 20 42		s_bad_object:   .null   "PANIC: Bad object in AST: "    ; from printer
>8554	61 64 20 6f 62 6a 65 63 74 20 69 6e 20 41 53 54
>8564	3a 20 00
>8567	3b 49 6c 6c 2d 66 6f 72		s_bad_number:   .null   ";Ill-formed number"            ; from lexer
>856f	6d 65 64 20 6e 75 6d 62 65 72 00
>857a	50 41 4e 49 43 3a 20 42		s_bad_radix:    .null   "PANIC: Bad radix: $"           ; from parser
>8582	61 64 20 72 61 64 69 78 3a 20 24 00
>858e	41 4c 50 48 41 3a 20 43		s_cant_yet      .null   "ALPHA: Can't do that yet"      ; from parser
>8596	61 6e 27 74 20 64 6f 20 74 68 61 74 20 79 65 74
>85a6	00
>85a7	21 24 25 26 2a 2b 2d 2e		s_extended:     .null "!$%&*+-./:<=>?@^_~"
>85af	2f 3a 3c 3d 3e 3f 40 5e 5f 7e 00

;******  Return to file: platforms/platform-py65mon.asm

>f000					.fill io_size                           ; Save space for the py65mon I/O
.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp cthulhu
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	43 74 68 75 6c 68 75 20		        .null "Cthulhu Scheme default kernel for py65mon (03. Apr 2020)", Asclf
>f034	53 63 68 65 6d 65 20 64 65 66 61 75 6c 74 20 6b
>f044	65 72 6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f
>f054	6e 20 28 30 33 2e 20 41 70 72 20 32 30 32 30 29
>f064	0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
