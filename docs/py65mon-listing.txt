
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output cthulhu-py65mon.bin platforms/platform-py65mon.asm
; Sat Apr 18 10:14:21 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platforms/platform-py65mon.asm

=true					DEBUG = true
=true					STRING_CR_TO_LF = true
=false					OCTAL = false
=$0000					ram_start = $0000       ; Start of RAM. Must contain the Zero Page
=$8000					ram_size  = $8000       ; assumes 32 KiB of RAM
=$0000					zp_start  = $0000       ; start of zero page,
=$80					zp_size   = $80         ; max bytes allowed in Zero Page
=$0200					buffers_start   = $0200         ; start of the buffer RAM area
=$100					cib_size        = $100          ; size of the input buffer, used by reader
=$100					tkb_size        = $100          ; size of the token buffer, used by lexer
=31744					heap_size       = ram_size - ($200+cib_size+tkb_size)
=$f000					io_start = $f000
=$10					io_size  = $10
=$8000					rom_start = $8000                       ; $8000 by default
=28672					rom_size = io_start - rom_start         ; $f000 - $8000 = $7000 (28 KiB)
=$fffa					vectors_start = $fffa
=$ffff					max_address   = $ffff

;******  Processing file: platforms/../cthulhu.asm

.8000					cthulhu:
.8000	d8		cld		                        cld
.8001	a9 27		lda #$27	                        lda #<kernel_putc
.8003	85 06		sta $06		                        sta output
.8005	a9 f0		lda #$f0	                        lda #>kernel_putc
.8007	85 07		sta $07		                        sta output+1
.8009	a9 00		lda #$00	                        lda <#heap
.800b	85 13		sta $13		                        sta hp
.800d	a9 04		lda #$04	                        lda >#heap
.800f	85 14		sta $14		                        sta hp+1
.8011	64 15		stz $15		                        stz symtbl
.8013	64 16		stz $16		                        stz symtbl+1
.8015	64 17		stz $17		                        stz strtbl
.8017	64 18		stz $18		                        stz strtbl+1
.8019	64 19		stz $19		                        stz bnmtbl
.801b	64 1a		stz $1a		                        stz bnmtbl+1
.801d	64 1b		stz $1b		                        stz ast
.801f	64 1c		stz $1c		                        stz ast+1
.8021	a9 21		lda #$21	                        lda #<kernel_getc
.8023	85 08		sta $08		                        sta input
.8025	a9 f0		lda #$f0	                        lda #>kernel_putc
.8027	85 09		sta $09		                        sta input+1
.8029					repl:
.8029	64 0a		stz $0a		                        stz ciblen
.802b	64 0b		stz $0b		                        stz ciblen+1

;******  Processing file: platforms/../reader.asm

.802d					reader:
.802d	64 0e		stz $0e		                        stz input_f
.802f	a9 0b		lda #$0b	                        lda #str_prompt
.8031	20 4a 84	jsr $844a	                        jsr help_print_string_no_lf
.8034	a0 00		ldy #$00	                        ldy #0
.8036					reader_loop:
.8036	20 47 84	jsr $8447	                        jsr help_key_a
.8039	c9 0a		cmp #$0a	                        cmp #AscLF
.803b	f0 3b		beq $8078	                        beq reader_got_eol
.803d	c9 0d		cmp #$0d	                        cmp #AscCR
.803f	f0 37		beq $8078	                        beq reader_got_eol
.8041					_not_an_eol:
.8041					_not_a_parens:
.8041	c9 3b		cmp #$3b	                        cmp #$3B                ; semicolon
.8043	d0 08		bne $804d	                        bne _not_a_comment
.8045	aa		tax		                        tax                     ; Save semicolon char
.8046	a9 80		lda #$80	                        lda #$80                ; Get ready to set bit 7
.8048	04 0e		tsb $0e		                        tsb input_f             ; 65c02 only
.804a	8a		txa		                        txa
.804b	80 1d		bra $806a	                        bra reader_comment_continue     ; saves char
.804d					_not_a_comment:
.804d	c9 22		cmp #$22	                        cmp #$22                ; quotation mark '"'
.804f	d0 0a		bne $805b	                        bne _not_a_string
.8051	aa		tax		                        tax                     ; Save quotation mark char
.8052	a5 0e		lda $0e		                        lda input_f
.8054	49 40		eor #$40	                        eor #%01000000          ; flip bit 6
.8056	85 0e		sta $0e		                        sta input_f
.8058	8a		txa		                        txa
.8059	80 0f		bra $806a	                        bra reader_string_continue      ; saves char
.805b					_not_a_string:
.805b	c9 08		cmp #$08	                        cmp #AscBS
.805d	f0 2e		beq $808d	                        beq reader_backspace
.805f	c9 7f		cmp #$7f	                        cmp #AscDEL             ; Is the same as CTRL-h
.8061	f0 2a		beq $808d	                        beq reader_backspace
.8063	c9 04		cmp #$04	                        cmp #$04
.8065	d0 03		bne $806a	                        bne reader_normal_char
.8067	4c 1b 84	jmp $841b	                        jmp repl_quit
.806a					reader_normal_char:
.806a					reader_comment_continue:
.806a					reader_string_continue:
.806a	20 44 84	jsr $8444	                        jsr help_emit_a
.806d	99 00 02	sta $0200,y	                        sta cib,y
.8070	c8		iny		                        iny
.8071	cc 00 01	cpy $0100	                        cpy cib_size
.8074	90 34		bcc $80aa	                        bcc reader_buffer_full
.8076	80 be		bra $8036	                        bra reader_loop
.8078					reader_got_eol:
.8078	a5 0e		lda $0e		                        lda input_f             ; bit 7 marks comment
.807a	30 09		bmi $8085	                        bmi _eol_in_comment
.807c	29 7f		and #$7f	                        and #%01111111          ; input_f already in A
.807e	d0 09		bne $8089	                        bne _eol_in_parens_or_string
.8080	20 44 84	jsr $8444	                        jsr help_emit_a
.8083	80 25		bra $80aa	                        bra reader_input_done
.8085					_eol_in_comment:
.8085	a9 80		lda #$80	                        lda #$80
.8087	14 0e		trb $0e		                        trb input_f             ; bit 7 marks comment, now clear
.8089					_eol_in_parens_or_string:
.8089	a9 0a		lda #$0a	                        lda #AscLF
.808b	80 dd		bra $806a	                        bra reader_comment_continue       ; stores LF
.808d					reader_backspace:
.808d	c0 00		cpy #$00	                        cpy #0          ; buffer empty?
.808f	d0 06		bne $8097	                        bne _skip_bell
.8091	a9 07		lda #$07	                        lda #AscBELL
.8093	20 44 84	jsr $8444	                        jsr help_emit_a
.8096	c8		iny		                        iny
.8097					_skip_bell:
.8097	88		dey		                        dey
.8098	a9 08		lda #$08	                        lda #AscBS      ; move back one
.809a	20 44 84	jsr $8444	                        jsr help_emit_a
.809d	a9 20		lda #$20	                        lda #AscSP      ; print a space (rubout)
.809f	20 44 84	jsr $8444	                        jsr help_emit_a
.80a2	a9 08		lda #$08	                        lda #AscBS      ; move back over space
.80a4	20 44 84	jsr $8444	                        jsr help_emit_a
.80a7	4c 36 80	jmp $8036	                        jmp reader_loop
.80aa					reader_input_done:
.80aa					reader_buffer_full:
.80aa	84 0a		sty $0a		                        sty ciblen      ; Y contains number of chars accepted already
.80ac	a9 00		lda #$00	                        lda #0
.80ae	85 0b		sta $0b		                        sta ciblen+1    ; we only accept 254 chars for now
.80b0	99 00 02	sta $0200,y	                        sta cib,y

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../lexer.asm

.80b3					lexer:
.80b3	20 bd 84	jsr $84bd	                        jsr debug_dump_input
.80b6	a0 00		ldy #$00	                        ldy #0
.80b8	64 0c		stz $0c		                        stz cibp
.80ba	64 0d		stz $0d		                        stz cibp+1      ; MSB currently unused
.80bc	64 11		stz $11		                        stz tkbp
.80be	64 12		stz $12		                        stz tkbp+1      ; MSB currently unused
.80c0	98		tya		                        tya
.80c1	19 00 02	ora $0200,y	                        ora cib,y
.80c4	d0 03		bne $80c9	                        bne lexer_loop
.80c6	4c 18 84	jmp $8418	                        jmp repl_empty_line
.80c9					lexer_loop:
.80c9	b9 00 02	lda $0200,y	                        lda cib,y
.80cc	c9 3b		cmp #$3b	                        cmp #$3B        ; semicolon
.80ce	d0 0f		bne $80df	                        bne _no_comment
.80d0					_comment_loop:
.80d0	c8		iny		                        iny
.80d1	b9 00 02	lda $0200,y	                        lda cib,y
.80d4	c9 0a		cmp #$0a	                        cmp #AscLF
.80d6	f0 04		beq $80dc	                        beq _comment_done
.80d8	c9 0d		cmp #$0d	                        cmp #AscCR
.80da	d0 f4		bne $80d0	                        bne _comment_loop
.80dc					_comment_done:
.80dc	4c c3 81	jmp $81c3	                        jmp lexer_next
.80df					_no_comment:
.80df	20 7e 84	jsr $847e	                        jsr help_is_whitespace
.80e2	90 03		bcc $80e7	                        bcc _not_whitespace
.80e4	4c c3 81	jmp $81c3	                        jmp lexer_next
.80e7					_not_whitespace:
.80e7					_test_parens:
.80e7					_test_done:
.80e7	d0 03		bne $80ec	                        bne _not_done
.80e9	4c cb 81	jmp $81cb	                        jmp lexer_end_of_input          ; not the same as lexer_done
.80ec					_not_done:
.80ec	c9 23		cmp #$23	                        cmp #'#'
.80ee	f0 03		beq $80f3	                        beq _got_sharp
.80f0	4c 90 81	jmp $8190	                        jmp lexer_not_sharp             ; too far for branch
.80f3					_got_sharp:
.80f3	c8		iny		                        iny
.80f4	b9 00 02	lda $0200,y	                        lda cib,y
.80f7	c9 74		cmp #$74	                        cmp #'t'        ; We're optimists so we check for true first
.80f9	d0 08		bne $8103	                        bne _not_true
.80fb	a9 10		lda #$10	                        lda #T_TRUE
.80fd	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8100	4c c3 81	jmp $81c3	                        jmp lexer_next
.8103					_not_true:
.8103	c9 66		cmp #$66	                        cmp #'f'
.8105	d0 08		bne $810f	                        bne _not_false
.8107	a9 11		lda #$11	                        lda #T_FALSE
.8109	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.810c	4c c3 81	jmp $81c3	                        jmp lexer_next
.810f					_not_false:
.810f	c9 5c		cmp #$5c	                        cmp #'\'
.8111	d0 00		bne $8113	                        bne _no_backslash
.8113					_not_single_char:
.8113					_not_named_char:
.8113					_no_backslash:
.8113					_not_vector:
.8113	c9 78		cmp #$78	                        cmp #'x'        ; #x is hexadecimal
.8115	d0 04		bne $811b	                        bne _not_hexnum
.8117	a9 10		lda #$10	                        lda #$10        ; Base 16
.8119	80 13		bra $812e	                        bra lexer_got_number
.811b					_not_hexnum:
.811b	c9 62		cmp #$62	                        cmp #'b'        ; #b is binary
.811d	d0 04		bne $8123	                        bne _not_binnum
.811f	a9 02		lda #$02	                        lda #$02        ; Base 2
.8121	80 0b		bra $812e	                        bra lexer_got_number
.8123					_not_binnum:
.8123	c9 64		cmp #$64	                        cmp #'d'        ; #d is explicit decimal
.8125	d0 04		bne $812b	                        bne _illegal_radix
.8127	a9 0a		lda #$0a	                        lda #$0A        ; Base 10
.8129	80 03		bra $812e	                        bra lexer_got_number
.812b					_illegal_radix:
.812b	4c 88 81	jmp $8188	                        jmp lexer_illegal_radix
.812e					lexer_got_number:
.812e	48		pha		                        pha                     ; Save the radix for the moment
.812f	a9 12		lda #$12	                        lda #T_NUM_START
.8131	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8134	68		pla		                        pla
.8135	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8138	a6 11		ldx $11		                        ldx tkbp        ; get index of where length will be
.813a	86 00		stx $00		                        stx tmp0
.813c	a9 00		lda #$00	                        lda #0          ; dummy length value
.813e	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8141	c8		iny		                        iny             ; Y is still the input buffer index
.8142	b9 00 02	lda $0200,y	                        lda cib,y
.8145	a2 00		ldx #$00	                        ldx #0          ; X counts length of string
.8147	c9 2d		cmp #$2d	                        cmp #'-'
.8149	d0 09		bne $8154	                        bne _check_for_plus
.814b	a9 ff		lda #$ff	                        lda #T_MINUS
.814d	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8150	c8		iny		                        iny             ; skip minus character
.8151	e8		inx		                        inx             ; string now has length of 1
.8152	80 0b		bra $815f	                        bra _sign_done
.8154					_check_for_plus:
.8154	c9 2b		cmp #$2b	                        cmp #'+'
.8156	d0 01		bne $8159	                        bne _default_plus
.8158	c8		iny		                        iny
.8159					_default_plus:
.8159	a9 ee		lda #$ee	                        lda #T_PLUS
.815b	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.815e	e8		inx		                        inx             ; string now has length of 1
.815f					_sign_done:
.815f	b9 00 02	lda $0200,y	                        lda cib,y
.8162	f0 24		beq $8188	                        beq lexer_terminator_too_early  ; 00 terminates input
.8164	20 78 84	jsr $8478	                        jsr help_is_delimiter
.8167	b0 1f		bcs $8188	                        bcs lexer_delimiter_too_early
.8169					_number_loop:
.8169	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.816c	e8		inx		                        inx             ; String one character longer
.816d	c8		iny		                        iny             ; Next character
.816e	b9 00 02	lda $0200,y	                        lda cib,y
.8171	f0 07		beq $817a	                        beq _legal_terminator
.8173	20 78 84	jsr $8478	                        jsr help_is_delimiter
.8176	b0 02		bcs $817a	                        bcs _number_done
.8178	80 ef		bra $8169	                        bra _number_loop
.817a					_legal_terminator:
.817a					_number_done:
.817a	a9 82		lda #$82	                        lda #T_NUM_END
.817c	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.817f	8a		txa		                        txa             ; number of chars was in X
.8180	a6 00		ldx $00		                        ldx tmp0        ; index of length byte in token stream
.8182	9d 00 03	sta $0300,x	                        sta tkb,x
.8185	4c c4 81	jmp $81c4	                        jmp lexer_next_same_char
.8188					lexer_illegal_radix:
.8188					lexer_terminator_too_early:
.8188					lexer_delimiter_too_early:
.8188	a9 06		lda #$06	                        lda #str_bad_number
.818a	20 64 84	jsr $8464	                        jsr help_print_string
.818d	4c 29 80	jmp $8029	                        jmp repl
.8190					lexer_not_octnum
.8190					lexer_not_sharp:
.8190					_not_decnum:
.8190	c9 22		cmp #$22	                        cmp #$22        ; '"' ASCII value
.8192	d0 1f		bne $81b3	                        bne _not_string
.8194	a9 13		lda #$13	                        lda #T_STR_START
.8196	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.8199					_string_loop:
.8199	c8		iny		                        iny
.819a	b9 00 02	lda $0200,y	                        lda cib,y
.819d	c9 22		cmp #$22	                        cmp #$22        ; '"' closes string
.819f	f0 0b		beq $81ac	                        beq _string_done
.81a1	c9 0d		cmp #$0d	                        cmp #AscCR
.81a3	d0 02		bne $81a7	                        bne +
.81a5	a9 0a		lda #$0a	                        lda #AscLF
.81a7					+
.81a7	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.81aa	80 ed		bra $8199	                        bra _string_loop
.81ac					_string_done:
.81ac	a9 83		lda #$83	                        lda #T_STR_END
.81ae	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.81b1	80 10		bra $81c3	                        bra lexer_next
.81b3					_not_string:
.81b3					lexer_error:
.81b3	48		pha		                        pha
.81b4	a9 00		lda #$00	                        lda #str_unbound
.81b6	20 4a 84	jsr $844a	                        jsr help_print_string_no_lf
.81b9	68		pla		                        pla
.81ba	20 2b 84	jsr $842b	                        jsr help_byte_to_ascii
.81bd	20 42 84	jsr $8442	                        jsr help_emit_lf
.81c0	4c 29 80	jmp $8029	                        jmp repl
.81c3					lexer_next:
.81c3	c8		iny		                        iny
.81c4					lexer_next_same_char:
.81c4	c4 0a		cpy $0a		                        cpy ciblen
.81c6	f0 03		beq $81cb	                        beq lexer_end_of_input
.81c8	4c c9 80	jmp $80c9	                        jmp lexer_loop
.81cb					lexer_end_of_input:
.81cb	a9 00		lda #$00	                        lda #T_END
.81cd	20 d3 81	jsr $81d3	                        jsr lexer_add_token
.81d0	4c de 81	jmp $81de	                        jmp lexer_done
.81d3					lexer_add_token:
.81d3	5a		phy		                        phy             ; Could also store in cibp
.81d4	a4 11		ldy $11		                        ldy tkbp
.81d6	99 00 03	sta $0300,y	                        sta tkb,y       ; LSB is in A
.81d9	c8		iny		                        iny
.81da	84 11		sty $11		                        sty tkbp
.81dc	7a		ply		                        ply
.81dd	60		rts		                        rts
=$00					T_END           = $00
=$01					T_PAREN_OPEN    = $01   ; '('
=$02					T_PAREN_CLOSED  = $02   ; ')'
=$03					T_SHARP         = $03   ; '#' - note '#f', '#t' and others are precprocessed
=$10					T_TRUE       = $10   ; '#t'
=$11					T_FALSE      = $11   ; '#f'
=$12					T_NUM_START  = $12   ; Marks beginning of a number sequence
=$13					T_STR_START  = $13   ; Marks beginning of a string
=$82					T_NUM_END    = $82   ; Marks end of a number sequence, see T_NUM_START
=$83					T_STR_END    = $83   ; Marks end of a string, see T_STR_START
=$ee					T_PLUS       = $EE   ; Also used in number token sequence
=$ff					T_MINUS      = $FF   ; Also used in number token sequence
.81de					lexer_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../parser.asm

.81de					parser:
.81de	20 da 84	jsr $84da	                        jsr debug_dump_token
.81e1	64 1b		stz $1b		                        stz ast
.81e3	64 1c		stz $1c		                        stz ast+1
.81e5	64 11		stz $11		                        stz tkbp
.81e7	64 12		stz $12		                        stz tkbp+1      ; fake, currently only using LSB
.81e9	a9 1b		lda #$1b	                        lda <#ast
.81eb	85 1d		sta $1d		                        sta astp
.81ed	a9 00		lda #$00	                        lda >#ast       ; paranoid, MSB always 00 for zero page
.81ef	85 1e		sta $1e		                        sta astp+1
.81f1	a2 ff		ldx #$ff	                        ldx #$FF
.81f3					parser_loop:
.81f3	e8		inx		                        inx
.81f4	bd 00 03	lda $0300,x	                        lda tkb,x
.81f7					_end_token:
.81f7	c9 00		cmp #$00	                        cmp #T_END
.81f9	d0 03		bne $81fe	                        bne _not_end_token
.81fb	4c 5a 83	jmp $835a	                        jmp parser_done
.81fe					_not_end_token:
.81fe	c9 10		cmp #$10	                        cmp #T_TRUE
.8200	d0 0a		bne $820c	                        bne _not_true_token
.8202	a9 ff		lda #$ff	                        lda <#OC_TRUE
.8204	a0 1f		ldy #$1f	                        ldy >#OC_TRUE
.8206	20 18 83	jsr $8318	                        jsr parser_add_object
.8209	4c f3 81	jmp $81f3	                        jmp parser_loop
.820c					_not_true_token:
.820c	c9 11		cmp #$11	                        cmp #T_FALSE
.820e	d0 0a		bne $821a	                        bne _not_false_token
.8210	a9 00		lda #$00	                        lda <#OC_FALSE
.8212	a0 10		ldy #$10	                        ldy >#OC_FALSE
.8214	20 18 83	jsr $8318	                        jsr parser_add_object
.8217	4c f3 81	jmp $81f3	                        jmp parser_loop
.821a					_not_false_token:
.821a	c9 12		cmp #$12	                        cmp #T_NUM_START
.821c	f0 03		beq $8221	                        beq +
.821e	4c c7 82	jmp $82c7	                        jmp parser_not_num              ; Too far for BRA
.8221					+
.8221	64 02		stz $02		                        stz tmp1
.8223	64 03		stz $03		                        stz tmp1+1
.8225	e8		inx		                        inx             ; skip over T_NUM_START TOKEN
.8226	bd 00 03	lda $0300,x	                        lda tkb,x
.8229	85 00		sta $00		                        sta tmp0        ; radix
.822b	e8		inx		                        inx
.822c	bd 00 03	lda $0300,x	                        lda tkb,x
.822f	a8		tay		                        tay             ; we need the length of the string later ...
.8230	88		dey		                        dey             ; ... but we don't need to include the sign
.8231	e8		inx		                        inx             ; Move to token for sign, T_PLUS or T_MINUS
.8232	bd 00 03	lda $0300,x	                        lda tkb,x
.8235	85 01		sta $01		                        sta tmp0+1      ; Just store sign for now
.8237	e8		inx		                        inx
.8238	a5 00		lda $00		                        lda tmp0        ; radix
.823a	c9 0a		cmp #$0a	                        cmp #$0a
.823c	d0 03		bne $8241	                        bne _not_dec
.823e	4c af 82	jmp $82af	                        jmp parser_common_fixnum
.8241					_not_dec:
.8241	c9 10		cmp #$10	                        cmp #$10
.8243	d0 36		bne $827b	                        bne _not_hex
.8245	98		tya		                        tya
.8246	c9 04		cmp #$04	                        cmp #$04
.8248	90 03		bcc $824d	                        bcc _dec_fixnum
.824a	4c 10 83	jmp $8310	                        jmp function_not_available
.824d					_dec_fixnum:
.824d					_hex_fixnum_loop:
.824d	bd 00 03	lda $0300,x	                lda tkb,x
.8250	c9 82		cmp #$82	                cmp #T_NUM_END
.8252	f0 24		beq $8278	                beq _done_hex
.8254	20 95 84	jsr $8495	                jsr help_hexascii_to_value
.8257	10 03		bpl $825c	                bpl _legal_hex_digit
.8259	4c 08 83	jmp $8308	                jmp parser_bad_digit
.825c					_legal_hex_digit:
.825c	0a		asl a		                asl
.825d	0a		asl a		                asl
.825e	0a		asl a		                asl
.825f	0a		asl a		                asl
.8260	2a		rol a		                rol             ; bit 7 of A now in carry flag
.8261	26 03		rol $03		                rol tmp1+1      ; bit 7 of tmp1+1 now in carry flag
.8263	26 02		rol $02		                rol tmp1        ; now is bit 0 of tmp1
.8265	2a		rol a		                rol
.8266	26 03		rol $03		                rol tmp1+1
.8268	26 02		rol $02		                rol tmp1
.826a	2a		rol a		                rol
.826b	26 03		rol $03		                rol tmp1+1
.826d	26 02		rol $02		                rol tmp1
.826f	2a		rol a		                rol
.8270	26 03		rol $03		                rol tmp1+1
.8272	26 02		rol $02		                rol tmp1
.8274	e8		inx		                inx
.8275	88		dey		                dey
.8276	d0 d5		bne $824d	                bne _hex_fixnum_loop
.8278					_done_hex:
.8278	4c af 82	jmp $82af	                jmp parser_common_fixnum
.827b					_not_hex:
.827b	c9 02		cmp #$02	                cmp #$02
.827d	d0 28		bne $82a7	                bne _not_binary
.827f	98		tya		                tya
.8280	c9 0d		cmp #$0d	                cmp #$0D                ; "smaller than 13"
.8282	90 03		bcc $8287	                bcc _bin_fixnum
.8284	4c 10 83	jmp $8310	                jmp function_not_available
.8287					_bin_fixnum:
.8287					_bin_fixnum_loop:
.8287	bd 00 03	lda $0300,x	                lda tkb,x
.828a	c9 30		cmp #$30	                cmp #'0'
.828c	f0 0b		beq $8299	                beq _legal_bit_char
.828e	c9 31		cmp #$31	                cmp #'1'
.8290	f0 07		beq $8299	                beq _legal_bit_char
.8292	c9 82		cmp #$82	                cmp #T_NUM_END
.8294	f0 0e		beq $82a4	                beq _done_bin
.8296	4c 08 83	jmp $8308	                jmp parser_bad_digit
.8299					_legal_bit_char:
.8299	29 01		and #$01	                and #$01                ; gives us $00 or $01
.829b	6a		ror a		                ror                     ; push the bit into carry flag
.829c	26 03		rol $03		                rol tmp1+1              ; rotate the carry flag into LSB ...
.829e	26 02		rol $02		                rol tmp1                ; ... and highest bit of tmp1+1 to tmp1
.82a0	e8		inx		                inx
.82a1	88		dey		                dey
.82a2	d0 e3		bne $8287	                bne _bin_fixnum_loop    ; Repeat till we're done
.82a4					_done_bin:
.82a4	4c af 82	jmp $82af	                jmp parser_common_fixnum
.82a7					_not_binary:
.82a7					_illegal_radix:
.82a7	48		pha		                pha                             ; save the evil radix
.82a8	a9 07		lda #$07	                lda #str_bad_radix
.82aa	20 4a 84	jsr $844a	                jsr help_print_string_no_lf
.82ad	80 4f		bra $82fe	                bra parser_common_panic         ; prints offending byte and LF
.82af					parser_common_fixnum:
.82af	a5 01		lda $01		                lda tmp0+1
.82b1	c9 ff		cmp #$ff	                cmp #T_MINUS
.82b3	f0 08		beq $82bd	                beq _negative_number
.82b5	a9 20		lda #$20	                lda #OT_FIXNUM
.82b7	05 02		ora $02		                ora tmp1
.82b9	85 02		sta $02		                sta tmp1
.82bb	80 00		bra $82bd	                bra _add_fixnum_to_ast
.82bd					_negative_number:
.82bd					_add_fixnum_to_ast:
.82bd	a5 03		lda $03		                lda tmp1+1
.82bf	a4 02		ldy $02		                ldy tmp1
.82c1	20 18 83	jsr $8318	                jsr parser_add_object
.82c4					_num_done:
.82c4	4c f3 81	jmp $81f3	                jmp parser_loop
.82c7					parser_not_num:
.82c7	c9 13		cmp #$13	                cmp #T_STR_START
.82c9	d0 2d		bne $82f8	                bne parser_not_string
.82cb	a5 13		lda $13		                lda hp
.82cd	85 02		sta $02		                sta tmp1                ; LSB
.82cf	a5 14		lda $14		                lda hp+1
.82d1	85 03		sta $03		                sta tmp1+1              ; MSB
.82d3	09 0f		ora #$0f	                ora #$0F                ; mask high nibble (paranoid)
.82d5	09 50		ora #$50	                ora #OT_STRING          ; object tag nibble for strings
.82d7	a4 02		ldy $02		                ldy tmp1
.82d9	20 18 83	jsr $8318	                jsr parser_add_object   ; Updates heap pointer
.82dc	a0 00		ldy #$00	                ldy #00
.82de					_string_loop:
.82de	bd 00 03	lda $0300,x	                lda tkb,x
.82e1	c9 83		cmp #$83	                cmp #T_STR_END
.82e3	f0 10		beq $82f5	                beq _string_done
.82e5	91 13		sta ($13),y	                sta (hp),y
.82e7	c8		iny		                iny
.82e8	e8		inx		                inx
.82e9	80 f3		bra $82de	                bra _string_loop
.82eb	98		tya		                tya
.82ec	18		clc		                clc
.82ed	65 13		adc $13		                adc hp
.82ef	85 13		sta $13		                sta hp
.82f1	90 02		bcc $82f5	                bcc _string_done
.82f3	e6 14		inc $14		                inc hp+1
.82f5					_string_done:
.82f5	4c f3 81	jmp $81f3	                jmp parser_loop
.82f8					parser_not_string:
.82f8					paser_bad_token:
.82f8	48		pha		                        pha                             ; save the evil token
.82f9	a9 04		lda #$04	                        lda #str_bad_token
.82fb	20 4a 84	jsr $844a	                        jsr help_print_string_no_lf
.82fe					parser_common_panic:
.82fe	68		pla		                        pla
.82ff	20 2b 84	jsr $842b	                        jsr help_byte_to_ascii          ; print bad token as hex number
.8302	20 42 84	jsr $8442	                        jsr help_emit_lf
.8305	4c 29 80	jmp $8029	                        jmp repl
.8308					parser_bad_digit:
.8308	48		pha		                        pha
.8309	a9 06		lda #$06	                        lda #str_bad_number
.830b	20 4a 84	jsr $844a	                        jsr help_print_string_no_lf
.830e	80 ee		bra $82fe	                        bra parser_common_panic
.8310					function_not_available:
.8310	a9 08		lda #$08	                        lda #str_cant_yet
.8312	20 64 84	jsr $8464	                        jsr help_print_string
.8315	4c 29 80	jmp $8029	                        jmp repl
.8318					parser_add_object:
.8318	da		phx		                        phx             ; save index to token buffer
.8319	5a		phy		                        phy             ; save MSB of the object
.831a	48		pha		                        pha             ; save LSB of the object
.831b	a5 13		lda $13		                        lda hp
.831d	85 00		sta $00		                        sta tmp0
.831f	a5 14		lda $14		                        lda hp+1
.8321	85 01		sta $01		                        sta tmp0+1
.8323	a9 00		lda #$00	                        lda <#OC_END
.8325	a0 00		ldy #$00	                        ldy #0
.8327	91 13		sta ($13),y	                        sta (hp),y
.8329	c8		iny		                        iny
.832a	a9 00		lda #$00	                        lda >#OC_END
.832c	91 13		sta ($13),y	                        sta (hp),y
.832e	c8		iny		                        iny
.832f	68		pla		                        pla             ; retrieve LSB
.8330	91 13		sta ($13),y	                        sta (hp),y
.8332	c8		iny		                        iny
.8333	68		pla		                        pla             ; retrieve MSB, was in Y
.8334	91 13		sta ($13),y	                        sta (hp),y
.8336	c8		iny		                        iny
.8337	a9 00		lda #$00	                        lda #0
.8339	91 13		sta ($13),y	                        sta (hp),y
.833b	c8		iny		                        iny
.833c	91 13		sta ($13),y	                        sta (hp),y
.833e	c8		iny		                        iny
.833f	98		tya		                        tya
.8340	18		clc		                        clc
.8341	65 13		adc $13		                        adc hp
.8343	85 13		sta $13		                        sta hp
.8345	90 02		bcc $8349	                        bcc _store_address
.8347	e6 14		inc $14		                        inc hp+1
.8349					_store_address:
.8349	a5 00		lda $00		                        lda tmp0        ; original LSB of hp
.834b	aa		tax		                        tax             ; We'll need it again in a second
.834c	92 1d		sta ($1d)	                        sta (astp)
.834e	a0 01		ldy #$01	                        ldy #1
.8350	a5 01		lda $01		                        lda tmp0+1      ; original MSB of hp
.8352	91 1d		sta ($1d),y	                        sta (astp),y
.8354	85 1e		sta $1e		                        sta astp+1      ; MSB, was tmp0+1
.8356	86 1d		stx $1d		                        stx astp        ; LSB, was tmp0
.8358	fa		plx		                        plx             ; get back index for token buffer
.8359	60		rts		                        rts
=$0000					OC_END   = $0000        ; end of input for AST
=$1fff					OC_TRUE  = $1fff        ; true bool #t, immediate
=$1000					OC_FALSE = $1000        ; false bool #f, immediate
.835a					parser_done:
.835a	a9 00		lda #$00	                        lda <#OC_END
.835c	a2 00		ldx #$00	                        ldx >#OC_END
.835e	20 18 83	jsr $8318	                        jsr parser_add_object

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../eval.asm

.8361					eval:
.8361	20 0d 85	jsr $850d	                        jsr debug_dump_ast
.8364	20 fb 84	jsr $84fb	                        jsr debug_dump_hp
.8367	a5 1b		lda $1b		                        lda ast
.8369	85 02		sta $02		                        sta tmp1
.836b	a5 1c		lda $1c		                        lda ast+1
.836d	85 03		sta $03		                        sta tmp1+1
.836f					eval_loop:
.836f	a0 03		ldy #$03	                        ldy #3          ; MSB of the next node entry down ...
.8371	b1 02		lda ($02),y	                        lda (tmp1),y    ; ...  which contains the tag nibble
.8373	29 f0		and #$f0	                        and #$f0        ; mask all but tag nibble
.8375	4a		lsr a		                        lsr
.8376	4a		lsr a		                        lsr
.8377	4a		lsr a		                        lsr             ; Fourth LSR and ASL cancle each other
.8378	aa		tax		                        tax
.8379	7c 8b 83	jmp ($838b,x)	                        jmp (eval_table,X)
.837c					eval_next:
.837c	b2 02		lda ($02)	                        lda (tmp1)              ; LSB of next entry
.837e	aa		tax		                        tax
.837f	a0 01		ldy #$01	                        ldy #1
.8381	b1 02		lda ($02),y	                        lda (tmp1),y            ; MSB of next entry
.8383	85 03		sta $03		                        sta tmp1+1
.8385	86 02		stx $02		                        stx tmp1
.8387	80 e6		bra $836f	                        bra eval_loop
.8389					eval_0_meta:
.8389					eval_1_bool:
.8389					eval_2_fixnum:
.8389					eval_3_bignum:
.8389					eval_4_char:
.8389					eval_5_string:
.8389	80 f1		bra $837c	                        bra eval_next           ; paranoid, never reached
.838b					eval_6_UNDEFINED:
.838b					eval_7_UNDEFINED:
.838b					eval_8_UNDEFINED:
.838b					eval_9_UNDEFINED:
.838b					eval_A_UNDEFINED:
.838b					eval_B_UNDEFINED:
.838b					eval_C_UNDEFINED:
.838b					eval_D_UNDEFINED:
.838b					eval_E_UNDEFINED:
.838b					eval_F_UNDEFINED:
.838b					eval_table:
>838b	ab 83 7c 83 7c 83 7c 83		        .word eval_done, eval_next, eval_next, eval_next
>8393	7c 83 7c 83 7c 83 7c 83		        .word eval_next, eval_next, eval_next, eval_next
>839b	7c 83 7c 83 7c 83 7c 83		        .word eval_next, eval_next, eval_next, eval_next
>83a3	7c 83 7c 83 7c 83 7c 83		        .word eval_next, eval_next, eval_next, eval_next
.83ab					eval_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../printer.asm

.83ab					printer:
.83ab	a5 1b		lda $1b		                        lda ast
.83ad	85 02		sta $02		                        sta tmp1
.83af	a5 1c		lda $1c		                        lda ast+1
.83b1	85 03		sta $03		                        sta tmp1+1
.83b3					printer_loop:
.83b3	20 42 84	jsr $8442	                        jsr help_emit_lf
.83b6	a0 03		ldy #$03	                        ldy #3          ; MSB of the next node entry down ...
.83b8	b1 02		lda ($02),y	                        lda (tmp1),y    ; ...  which contains the tag nibble
.83ba	29 f0		and #$f0	                        and #$f0        ; mask all but tag nibble
.83bc	4a		lsr a		                        lsr
.83bd	4a		lsr a		                        lsr
.83be	4a		lsr a		                        lsr     ; Fourth LSR and ASL cancle each other
.83bf	aa		tax		                        tax
.83c0	7c f8 83	jmp ($83f8,x)	                        jmp (printer_table,X)
.83c3					printer_next:
.83c3	b2 02		lda ($02)	                        lda (tmp1)      ; LSB of next entry
.83c5	aa		tax		                        tax
.83c6	a0 01		ldy #$01	                        ldy #1
.83c8	b1 02		lda ($02),y	                        lda (tmp1),y    ; MSB of next entry
.83ca	85 03		sta $03		                        sta tmp1+1
.83cc	86 02		stx $02		                        stx tmp1
.83ce	4c b3 83	jmp $83b3	                        jmp printer_loop
.83d1					printer_0_meta:
.83d1	80 45		bra $8418	                        bra printer_done
.83d3					printer_1_bool:
.83d3	a0 02		ldy #$02	                        ldy #2
.83d5	b1 02		lda ($02),y	                        lda (tmp1),y            ; LSB
.83d7	d0 04		bne $83dd	                        bne _bool_true          ; not a zero means true
.83d9	a9 03		lda #$03	                        lda #str_false
.83db	80 02		bra $83df	                        bra _bool_printer
.83dd					_bool_true:
.83dd	a9 02		lda #$02	                        lda #str_true
.83df					_bool_printer:
.83df	20 4a 84	jsr $844a	                        jsr help_print_string_no_lf
.83e2	80 df		bra $83c3	                        bra printer_next
.83e4					printer_2_fixnum:
.83e4	a0 03		ldy #$03	                        ldy #3          ; tag nibble and high nibble of number
.83e6	b1 02		lda ($02),y	                        lda (tmp1),y    ; MSB nibble
.83e8	29 0f		and #$0f	                        and #$0F        ; Mask tab
.83ea	20 2b 84	jsr $842b	                        jsr help_byte_to_ascii
.83ed	a0 02		ldy #$02	                        ldy #2
.83ef	b1 02		lda ($02),y	                        lda (tmp1),y    ; LSB
.83f1	20 2b 84	jsr $842b	                        jsr help_byte_to_ascii
.83f4	80 cd		bra $83c3	                        bra printer_next
.83f6					printer_3_bignum:
.83f6					printer_4_char:
.83f6					printer_5_string:
.83f6					printer_6_UNDEFINED:
.83f6					printer_7_UNDEFINED:
.83f6					printer_8_UNDEFINED:
.83f6					printer_9_UNDEFINED:
.83f6					printer_A_UNDEFINED:
.83f6					printer_B_UNDEFINED:
.83f6					printer_C_UNDEFINED:
.83f6					printer_D_UNDEFINED:
.83f6					printer_E_UNDEFINED:
.83f6					printer_F_UNDEFINED:
.83f6	80 cb		bra $83c3	                        bra printer_next
.83f8					printer_table:
>83f8	18 84 d3 83 e4 83 c3 83		        .word printer_done, printer_1_bool, printer_2_fixnum, printer_next
>8400	c3 83 f6 83 c3 83 c3 83		        .word printer_next, printer_5_string, printer_next, printer_next
>8408	c3 83 c3 83 c3 83 c3 83		        .word printer_next, printer_next, printer_next, printer_next
>8410	c3 83 c3 83 c3 83 c3 83		        .word printer_next, printer_next, printer_next, printer_next
.8418					printer_done:

;******  Return to file: platforms/../cthulhu.asm

.8418					repl_empty_line:
.8418	4c 29 80	jmp $8029	                        jmp repl
.841b					repl_quit:
.841b	20 42 84	jsr $8442	                        jsr help_emit_lf
.841e	a9 09		lda #$09	                        lda #str_end_input
.8420	20 64 84	jsr $8464	                        jsr help_print_string
.8423	a9 0a		lda #$0a	                        lda #str_chant
.8425	20 64 84	jsr $8464	                        jsr help_print_string
.8428	4c 2b f0	jmp $f02b	                        jmp platform_quit

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../helpers.asm

.842b					help_byte_to_ascii:
.842b	48		pha		                pha
.842c	4a		lsr a		                lsr             ; convert high nibble first
.842d	4a		lsr a		                lsr
.842e	4a		lsr a		                lsr
.842f	4a		lsr a		                lsr
.8430	20 34 84	jsr $8434	                jsr help_nibble_to_ascii
.8433	68		pla		                pla
.8434					help_nibble_to_ascii:
.8434	29 0f		and #$0f	                and #$0F
.8436	09 30		ora #$30	                ora #'0'
.8438	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.843a	90 02		bcc $843e	                bcc +
.843c	69 06		adc #$06	                adc #$06
.843e	4c 44 84	jmp $8444	+               jmp help_emit_a       ; JSR/RTS
.8441					help_to_lowercase:
.8441	60		rts		                rts
.8442					help_emit_lf:
.8442	a9 0a		lda #$0a	                lda #AscLF
.8444					help_emit_a:
.8444	6c 06 00	jmp ($0006)	                jmp (output)    ; JSR/RTS
.8447					help_key_a:
.8447	6c 08 00	jmp ($0008)	                jmp (input)             ; JSR/RTS
.844a					help_print_string_no_lf:
.844a	0a		asl a		                asl
.844b	a8		tay		                tay
.844c	b9 e1 85	lda $85e1,y	                lda string_table,y
.844f	85 00		sta $00		                sta tmp0                ; LSB
.8451	c8		iny		                iny
.8452	b9 e1 85	lda $85e1,y	                lda string_table,y
.8455	85 01		sta $01		                sta tmp0+1              ; MSB
.8457					help_print_common:
.8457	a0 00		ldy #$00	                ldy #0
.8459					_loop:
.8459	b1 00		lda ($00),y	                lda (tmp0),y
.845b	f0 06		beq $8463	                beq _done               ; strings are zero-terminated
.845d	20 44 84	jsr $8444	                jsr help_emit_a         ; allows vectoring via output
.8460	c8		iny		                iny
.8461	80 f6		bra $8459	                bra _loop
.8463					_done:
.8463	60		rts		                rts
.8464					help_print_string:
.8464	20 4a 84	jsr $844a	                jsr help_print_string_no_lf
.8467	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.8469	4c 44 84	jmp $8444	                jmp help_emit_a         ; JSR/RTS
.846c					help_is_decdigit:
.846c	c9 30		cmp #$30	                cmp #'0'
.846e	90 07		bcc $8477	                bcc _below_zero         ; A is < '0'
.8470	c9 3a		cmp #$3a	                cmp #':'                ; A is >= ':', which is '9'+1
.8472	b0 02		bcs $8476	                bcs _above_nine
.8474	38		sec		                sec
.8475	60		rts		                rts
.8476					_above_nine:
.8476	18		clc		                clc
.8477					_below_zero:
.8477	60		rts		                rts
.8478					help_is_delimiter:
.8478	20 7e 84	jsr $847e	                jsr help_is_whitespace
.847b	b0 00		bcs $847d	                bcs _delimiter_done
.847d					_delimiter_done:
.847d	60		rts		                rts
.847e					help_is_whitespace:
.847e	38		sec		                sec             ; default is whitespace
.847f	c9 20		cmp #$20	                cmp #$20        ; SPACE, assumed to be the most common char
.8481	f0 11		beq $8494	                beq _done
.8483	c9 09		cmp #$09	                cmp #$09        ; TAB, probably the second most common in Scheme
.8485	f0 0d		beq $8494	                beq _done
.8487	c9 0a		cmp #$0a	                cmp #$0A        ; Linefeed, normally ends input but not with Scheme
.8489	f0 09		beq $8494	                beq _done
.848b	c9 0d		cmp #$0d	                cmp #$0D        ; Return, normally ends input but not with Scheme
.848d	f0 05		beq $8494	                beq _done
.848f	c9 0c		cmp #$0c	                cmp #$0C        ; Page, which is strange, but in the standard
.8491	f0 01		beq $8494	                beq _done
.8493	18		clc		                clc             ; If we end up here, it's not whitespace
.8494					_done:
.8494	60		rts		                rts
.8495					help_hexascii_to_value:
.8495	20 6c 84	jsr $846c	                jsr help_is_decdigit
.8498	90 05		bcc $849f	                bcc _see_if_letter
.849a	38		sec		                sec
.849b	e9 30		sbc #$30	                sbc #'0'
.849d	80 0f		bra $84ae	                bra _done
.849f					_see_if_letter:
.849f	c9 41		cmp #$41	                cmp #'A'        ; lower than 'A' can't be right
.84a1	90 17		bcc $84ba	                bcc _error
.84a3	c9 67		cmp #$67	                cmp #'g'        ; 'g' or above can't be right
.84a5	b0 13		bcs $84ba	                bcs _error
.84a7	c9 61		cmp #$61	                cmp #'a'
.84a9	90 06		bcc $84b1	                bcc _uppercase
.84ab	38		sec		                sec
.84ac	e9 47		sbc #$47	                sbc #71         ; moves 'a' to 10 ($0A)
.84ae					_done:
.84ae	29 0f		and #$0f	                and #$0F        ; paranoid
.84b0	60		rts		                rts
.84b1					_uppercase:
.84b1	c9 47		cmp #$47	                cmp #'G'
.84b3	b0 05		bcs $84ba	                bcs _error
.84b5	38		sec		                sec
.84b6	e9 37		sbc #$37	                sbc #55         ; moves 'A' to 10 ($0A)
.84b8	80 f4		bra $84ae	                bra _done
.84ba					_error:
.84ba	a9 80		lda #$80	                lda #$80
.84bc	60		rts		                rts

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../native-procedures.asm

.84bd					proc_char_whitespace_p:
.84bd					proc_newline:
.84bd					proc_display:
.84bd					proc_read:
.84bd					proc_read_char:
.84bd					proc_read_line:
.84bd					proc_write_char:

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../procedures.asm


;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../debug.asm

.84bd					debug_dump_input:
.84bd	20 42 84	jsr $8442	                jsr help_emit_lf
.84c0	a9 03		lda #$03	                lda #strd_dump_input            ; "Input: "
.84c2	20 7a 85	jsr $857a	                jsr debug_print_string_no_lf
.84c5	a2 00		ldx #$00	                ldx #0
.84c7					-
.84c7	bd 00 02	lda $0200,x	                lda cib,x
.84ca	f0 0b		beq $84d7	                beq _done
.84cc	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.84cf	e8		inx		                inx
.84d0	a9 20		lda #$20	                lda #' '
.84d2	20 44 84	jsr $8444	                jsr help_emit_a
.84d5	80 f0		bra $84c7	                bra -
.84d7					_done:
.84d7	4c 2b 84	jmp $842b	                jmp help_byte_to_ascii          ; JSR/RTS
.84da					debug_dump_token:
.84da	20 42 84	jsr $8442	                jsr help_emit_lf
.84dd	a9 00		lda #$00	                lda #strd_dump_token            ; "Token: "
.84df	20 7a 85	jsr $857a	                jsr debug_print_string_no_lf
.84e2	a2 00		ldx #$00	                ldx #0
.84e4					-
.84e4	bd 00 03	lda $0300,x	                lda tkb,x
.84e7	c9 00		cmp #$00	                cmp #T_END
.84e9	f0 0d		beq $84f8	                beq _done
.84eb	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.84ee	e8		inx		                inx
.84ef	a9 20		lda #$20	                lda #' '
.84f1	20 44 84	jsr $8444	                jsr help_emit_a
.84f4	e4 11		cpx $11		                cpx tkbp
.84f6	d0 ec		bne $84e4	                bne -
.84f8					_done:
.84f8	4c 2b 84	jmp $842b	                jmp help_byte_to_ascii          ; JSR/RTS
.84fb					debug_dump_hp:
.84fb	20 42 84	jsr $8442	                jsr help_emit_lf
.84fe	a9 02		lda #$02	                lda #strd_dump_hp               ; "Heap pointer: "
.8500	20 7a 85	jsr $857a	                jsr debug_print_string_no_lf
.8503	a5 14		lda $14		                lda hp+1
.8505	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.8508	a5 13		lda $13		                lda hp
.850a	4c 2b 84	jmp $842b	                jmp help_byte_to_ascii          ; JSR/RTS
.850d					debug_dump_ast:
.850d	20 42 84	jsr $8442	                jsr help_emit_lf
.8510	a9 01		lda #$01	                lda #strd_dump_ast              ; "AST: "
.8512	20 7a 85	jsr $857a	                jsr debug_print_string_no_lf
.8515	a5 1c		lda $1c		                lda ast+1
.8517	85 03		sta $03		                sta tmp1+1
.8519	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.851c	a5 1b		lda $1b		                lda ast
.851e	85 02		sta $02		                sta tmp1
.8520	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.8523					_loop:
.8523	a9 20		lda #$20	                lda #' '
.8525	20 44 84	jsr $8444	                jsr help_emit_a
.8528	a0 01		ldy #$01	                ldy #1
.852a	b1 02		lda ($02),y	                lda (tmp1),y
.852c	85 05		sta $05		                sta tmp2+1
.852e	20 2b 84	jsr $842b	                jsr help_byte_to_ascii          ; MSB
.8531	b2 02		lda ($02)	                lda (tmp1)
.8533	85 04		sta $04		                sta tmp2                        ; pointer to next entry, LSB
.8535	20 2b 84	jsr $842b	                jsr help_byte_to_ascii          ; LSB
.8538	a9 3a		lda #$3a	                lda #':'
.853a	20 44 84	jsr $8444	                jsr help_emit_a
.853d	a0 03		ldy #$03	                ldy #3
.853f	b1 02		lda ($02),y	                lda (tmp1),y
.8541	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.8544	a0 02		ldy #$02	                ldy #2
.8546	b1 02		lda ($02),y	                lda (tmp1),y
.8548	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.854b	a9 3a		lda #$3a	                lda #':'
.854d	20 44 84	jsr $8444	                jsr help_emit_a
.8550	a0 05		ldy #$05	                ldy #5
.8552	b1 02		lda ($02),y	                lda (tmp1),y
.8554	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.8557	a0 04		ldy #$04	                ldy #4
.8559	b1 02		lda ($02),y	                lda (tmp1),y
.855b	20 2b 84	jsr $842b	                jsr help_byte_to_ascii
.855e	a5 04		lda $04		                lda tmp2
.8560	05 05		ora $05		                ora tmp2+1      ; Cheating: We know that OC_END is 0000
.8562	f0 0a		beq $856e	                beq _done
.8564	a5 04		lda $04		                lda tmp2
.8566	85 02		sta $02		                sta tmp1
.8568	a5 05		lda $05		                lda tmp2+1
.856a	85 03		sta $03		                sta tmp1+1
.856c	80 b5		bra $8523	                bra _loop
.856e					_done:
.856e	60		rts		                rts
.856f					debug_emit_a:
.856f	48		pha		                pha
.8570	20 42 84	jsr $8442	                jsr help_emit_lf
.8573	68		pla		                pla
.8574	20 44 84	jsr $8444	                jsr help_emit_a
.8577	4c 42 84	jmp $8442	                jmp help_emit_lf        ; JSR/RTS
.857a					debug_print_string_no_lf:
.857a	0a		asl a		                asl
.857b	a8		tay		                tay
.857c	b9 cd 85	lda $85cd,y	                lda sd_table,y
.857f	85 00		sta $00		                sta tmp0                ; LSB
.8581	c8		iny		                iny
.8582	b9 cd 85	lda $85cd,y	                lda sd_table,y
.8585	85 01		sta $01		                sta tmp0+1              ; MSB
.8587					debug_print_common:
.8587	a0 00		ldy #$00	                ldy #0
.8589					_loop:
.8589	b1 00		lda ($00),y	                lda (tmp0),y
.858b	f0 06		beq $8593	                beq _done               ; strings are zero-terminated
.858d	20 44 84	jsr $8444	                jsr help_emit_a         ; allows vectoring via output
.8590	c8		iny		                iny
.8591	80 f6		bra $8589	                bra _loop
.8593					_done:
.8593	60		rts		                rts
.8594					debug_print_string:
.8594	20 7a 85	jsr $857a	                jsr debug_print_string_no_lf
.8597	4c 42 84	jmp $8442	                jmp help_emit_lf        ; JSR/RTS
=0					strd_dump_token = 0
=1					strd_dump_ast   = 1
=2					strd_dump_hp    = 2
=3					strd_dump_input = 3
>859a	54 6f 6b 65 6e 20 42 75		s_dump_token:   .null   "Token Buffer: "
>85a2	66 66 65 72 3a 20 00
>85a9	41 53 54 3a 20 00		s_dump_ast:     .null   "AST: "
>85af	48 65 61 70 20 70 6f 69		s_dump_hp:      .null   "Heap pointer: "
>85b7	6e 74 65 72 3a 20 00
>85be	49 6e 70 75 74 20 42 75		s_dump_input:   .null   "Input Buffer: "
>85c6	66 66 65 72 3a 20 00
.85cd					sd_table:
>85cd	9a 85 a9 85 af 85 be 85		        .word s_dump_token, s_dump_ast, s_dump_hp, s_dump_input      ; 0-3

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../definitions.asm

=$03					        AscCC   = $03  ; break (CTRL-c)
=$07					        AscBELL = $07  ; bell sound
=$08					        AscBS   = $08  ; backspace
=$0a					        AscLF   = $0a  ; line feed
=$0d					        AscCR   = $0d  ; carriage return
=$1b					        AscESC  = $1b  ; escape
=$20					        AscSP   = $20  ; space
=$7f					        AscDEL  = $7f  ; delete (CTRL-h)
>0000					tmp0:    .word ?     ; temporary storage, eg printing
>0002					tmp1:    .word ?     ; temporary storage
>0004					tmp2:    .word ?     ; temporary storage
>0006					output:  .word ?     ; output port, addr of routine
>0008					input:   .word ?     ; input port, addr of routine
>000a					ciblen:  .word ?     ; current size of input buffer
>000c					cibp:    .word ?     ; index of current char in input buffer
>000e					input_f  .byte ?     ; input flag for Reader, see details there
>000f					tkblen:  .word ?     ; current size of the token buffer
>0011					tkbp:    .word ?     ; index of current token in token buffer
>0013					hp:      .word ?     ; pointer to next free heap entry
>0015					symtbl:  .word ?     ; pointer to first entry in symbol table in heap
>0017					strtbl:  .word ?     ; pointer to first entry in string table in heap
>0019					bnmtbl:  .word ?     ; pointer to first entry in bignum table in heap
>001b					ast      .word ?     ; pointer to root of Abstract Systax Tree (AST)
>001d					astp     .word ?     ; pointer to current entry in AST
>0200					cib:    .fill cib_size          ; current input buffer
>0300					tkb:    .fill tkb_size          ; token buffer
>0400					heap:   .fill heap_size         ; RAM available for heap
=$00					OT_META         = $00    ; used for end of input and other markers
=$10					OT_BOOL         = $10    ; used for #t and #f; immediate
=$20					OT_FIXNUM       = $20    ; used for fixed numbers; immediate
=$30					OT_BIGNUM       = $30    ; used for bignum
=$40					OT_CHAR         = $40    ; used for chars; immediate
=$50					OT_STRING       = $50
=$60					ot_undefined_06 = $60
=$70					ot_undefined_07 = $70
=$80					ot_undefined_08 = $80
=$90					ot_undefined_09 = $90
=$a0					ot_undefined_0a = $a0
=$b0					ot_undefined_0b = $b0
=$c0					ot_undefined_0c = $c0
=$d0					ot_undefined_0d = $d0
=$e0					ot_undefined_0e = $e0
=$f0					ot_undefined_0f = $f0

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../headers.asm

.85d5					h_newline:
>85d5	00 00				        .addr 0000              ; end of header list
>85d7	bd 84				        .addr proc_newline
>85d9	07				        .byte 7
>85da	6e 65 77 6c 69 6e 65		        .text "newline"

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../strings.asm

=0					str_unbound    = 0
=1					str_unspec     = 1
=2					str_true       = 2
=3					str_false      = 3
=4					str_bad_token  = 4
=5					str_bad_object = 5
=6					str_bad_number = 6
=7					str_bad_radix  = 7
=8					str_cant_yet   = 8      ; TODO temp during development
=9					str_end_input  = 9
=10					str_chant      = 10
=11					str_prompt     = 11
.85e1					string_table:
>85e1	f9 85 0d 86 27 86 2a 86		        .word s_unbound, s_unspec, s_true, s_false      ; 0-3
>85e9	2d 86 41 86 5c 86 72 86		        .word s_bad_token, s_bad_object, s_bad_number, s_bad_radix   ; 4-7
>85f1	86 86 9f 86 bc 86 f0 86		        .word s_cant_yet, s_end_input, s_chant, s_prompt             ; 8-11
>85f9	3b 55 6e 62 6f 75 6e 64		s_unbound:      .null   ";Unbound variable: "           ; REPL input error
>8601	20 76 61 72 69 61 62 6c 65 3a 20 00
>860d	3b 55 6e 73 70 65 63 69		s_unspec:       .null   ";Unspecified return value"     ; used eg with (display)
>8615	66 69 65 64 20 72 65 74 75 72 6e 20 76 61 6c 75
>8625	65 00
>8627	23 74 00			s_true:         .null   "#t"
>862a	23 66 00			s_false:        .null   "#f"
>862d	50 41 4e 49 43 3a 20 42		s_bad_token:    .null   "PANIC: Bad token: $"           ; from parser
>8635	61 64 20 74 6f 6b 65 6e 3a 20 24 00
>8641	50 41 4e 49 43 3a 20 42		s_bad_object:   .null   "PANIC: Bad object in AST: "    ; from printer
>8649	61 64 20 6f 62 6a 65 63 74 20 69 6e 20 41 53 54
>8659	3a 20 00
>865c	3b 49 6c 6c 2d 66 6f 72		s_bad_number:   .null   ";Ill-formed number: $"         ; from lexer
>8664	6d 65 64 20 6e 75 6d 62 65 72 3a 20 24 00
>8672	50 41 4e 49 43 3a 20 42		s_bad_radix:    .null   "PANIC: Bad radix: $"           ; from parser
>867a	61 64 20 72 61 64 69 78 3a 20 24 00
>8686	41 4c 50 48 41 3a 20 43		s_cant_yet      .null   "ALPHA: Can't do that yet"      ; from parser
>868e	61 6e 27 74 20 64 6f 20 74 68 61 74 20 79 65 74
>869e	00
>869f	45 6e 64 20 6f 66 20 69		s_end_input     .null   "End of input stream reached."  ; from reader
>86a7	6e 70 75 74 20 73 74 72 65 61 6d 20 72 65 61 63
>86b7	68 65 64 2e 00
>86bc	50 68 27 6e 67 6c 75 69		s_chant         .null   "Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn."   ; from reader
>86c4	20 6d 67 6c 77 27 6e 61 66 68 20 43 74 68 75 6c
>86d4	68 75 20 52 27 6c 79 65 68 20 77 67 61 68 27 6e
>86e4	61 67 6c 20 66 68 74 61 67 6e 2e 00
>86f0	3e 20 00			s_prompt        .null   "> "
>86f3	21 24 25 26 2a 2b 2d 2e		s_extended:     .null "!$%&*+-./:<=>?@^_~"
>86fb	2f 3a 3c 3d 3e 3f 40 5e 5f 7e 00

;******  Return to file: platforms/platform-py65mon.asm

>f000					.fill io_size                           ; Save space for the py65mon I/O
.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp cthulhu
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_quit:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	43 74 68 75 6c 68 75 20		        .null "Cthulhu Scheme default kernel for py65mon (13. Apr 2020)", Asclf
>f034	53 63 68 65 6d 65 20 64 65 66 61 75 6c 74 20 6b
>f044	65 72 6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f
>f054	6e 20 28 31 33 2e 20 41 70 72 20 32 30 32 30 29
>f064	0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
