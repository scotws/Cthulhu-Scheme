
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output cthulhu-py65mon.bin platforms/platform-py65mon.asm
; Fri Apr  3 13:24:47 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platforms/platform-py65mon.asm

=$0000					ram_start = $0000       ; Start of RAM. Must contain the Zero Page
=$8000					ram_size  = $8000       ; assumes 32 KiB of RAM
=$0000					zp_start  = $0000       ; start of zero page,
=$80					zp_size   = $80         ; max bytes allowed in Zero Page
=$0200					buffers_start = $0200    ; start of the buffer area
=$100					cib_size      = $100     ; size of the input buffer
=$f000					io_start = $f000
=$10					io_size  = $10
=32768					rom_start = ram_start + ram_size        ; $8000 by default
=28672					rom_size = io_start - rom_start         ; $f000 - $8000 = $7000 (28 KiB)
=$fffa					vectors_start = $fffa
=$ffff					max_address   = $ffff

;******  Processing file: platforms/../cthulhu.asm

.8000					code0:
.8000					cthulhu:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 08		sta $08		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 09		sta $09		                sta output+1
.8009	a9 21		lda #$21	                lda #<kernel_getc
.800b	85 0a		sta $0a		                sta input
.800d	a9 f0		lda #$f0	                lda #>kernel_putc
.800f	85 0b		sta $0b		                sta input+1
.8011					repl:
.8011	64 0c		stz $0c		                stz ciblen
.8013	64 0d		stz $0d		                stz ciblen+1
.8015					repl_read:
.8015	a0 00		ldy #$00	                ldy #0
.8017					repl_read_loop:
.8017	20 9f 80	jsr $809f	                jsr help_key_a
.801a	c9 0a		cmp #$0a	                cmp #AscLF
.801c	f0 19		beq $8037	                beq repl_read_eol
.801e	c9 0d		cmp #$0d	                cmp #AscCR
.8020	f0 15		beq $8037	                beq repl_read_eol
.8022	c9 08		cmp #$08	                cmp #AscBS
.8024	f0 17		beq $803d	                beq repl_read_backspace
.8026	c9 7f		cmp #$7f	                cmp #AscDEL             ; (CTRL-h)
.8028	f0 13		beq $803d	                beq repl_read_backspace
.802a	99 00 02	sta $0200,y	                sta cib0,y
.802d	c8		iny		                iny
.802e	20 9c 80	jsr $809c	                jsr help_emit_a
.8031	c4 ff		cpy $ff		                cpy cib_size-1        ; reached character limit?
.8033	d0 e2		bne $8017	                bne repl_read_loop    ; fall through if buffer limit reached
.8035	80 00		bra $8037	                bra repl_read_buffer_full
.8037					repl_read_eol:
.8037					repl_read_buffer_full:
.8037	84 0c		sty $0c		                sty ciblen      ; Y contains number of chars accepted already
.8039	64 0d		stz $0d		                stz ciblen+1    ; we only accept 256 chars
.803b	80 1c		bra $8059	                bra repl_tokenize
.803d					repl_read_backspace:
.803d	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.803f	d0 06		bne $8047	                bne +
.8041	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8043	20 9c 80	jsr $809c	                jsr help_emit_a
.8046	c8		iny		                iny
.8047					+
.8047	88		dey		                dey
.8048	a9 08		lda #$08	                lda #AscBS      ; move back one
.804a	20 9c 80	jsr $809c	                jsr help_emit_a
.804d	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.804f	20 9c 80	jsr $809c	                jsr help_emit_a
.8052	a9 08		lda #$08	                lda #AscBS      ; move back over space
.8054	20 9c 80	jsr $809c	                jsr help_emit_a
.8057	80 be		bra $8017	                bra repl_read_loop
.8059					repl_tokenize:
.8059	a9 0a		lda #$0a	                lda #AscLF
.805b	20 9c 80	jsr $809c	                jsr help_emit_a
.805e	a9 74		lda #$74	                lda #'t'
.8060	20 9c 80	jsr $809c	                jsr help_emit_a
.8063					repl_parse:
.8063	a9 0a		lda #$0a	                lda #AscLF
.8065	20 9c 80	jsr $809c	                jsr help_emit_a
.8068	a9 70		lda #$70	                lda #'p'
.806a	20 9c 80	jsr $809c	                jsr help_emit_a
.806d					repl_eval:
.806d	a9 0a		lda #$0a	                lda #AscLF
.806f	20 9c 80	jsr $809c	                jsr help_emit_a
.8072	a9 65		lda #$65	                lda #'e'
.8074	20 9c 80	jsr $809c	                jsr help_emit_a
.8077					repl_print:
.8077	a5 00		lda $00		                lda return
.8079	05 01		ora $01		                ora return+1
.807b	d0 05		bne $8082	                bne +
.807d	a9 00		lda #$00	                lda #str_unspec
.807f	20 bc 80	jsr $80bc	                jsr help_print_string
.8082					+
.8082					repl_done:
.8082	4c 11 80	jmp $8011	                jmp repl

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../helpers.asm

.8085					help_byte_to_ascii:
.8085	48		pha		                pha
.8086	4a		lsr a		                lsr             ; convert high nibble first
.8087	4a		lsr a		                lsr
.8088	4a		lsr a		                lsr
.8089	4a		lsr a		                lsr
.808a	20 8e 80	jsr $808e	                jsr help_nibble_to_ascii
.808d	68		pla		                pla
.808e					help_nibble_to_ascii:
.808e	29 0f		and #$0f	                and #$0F
.8090	09 30		ora #$30	                ora #'0'
.8092	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.8094	90 02		bcc $8098	                bcc +
.8096	69 06		adc #$06	                adc #$06
.8098	4c 27 f0	jmp $f027	+               jmp kernel_putc
.809b	60		rts		                rts
.809c					help_emit_a:
.809c	6c 08 00	jmp ($0008)	                jmp (output)    ; JSR/RTS
.809f					help_key_a:
.809f	6c 0a 00	jmp ($000a)	                jmp (input)             ; JSR/RTS
.80a2					help_print_string_no_lf:
.80a2	0a		asl a		                asl
.80a3	a8		tay		                tay
.80a4	b9 d9 80	lda $80d9,y	                lda string_table,y
.80a7	85 02		sta $02		                sta tmp0                ; LSB
.80a9	c8		iny		                iny
.80aa	b9 d9 80	lda $80d9,y	                lda string_table,y
.80ad	85 03		sta $03		                sta tmp0+1              ; MSB
.80af					help_print_common:
.80af	a0 00		ldy #$00	                ldy #0
.80b1					_loop:
.80b1	b1 02		lda ($02),y	                lda (tmp0),y
.80b3	f0 06		beq $80bb	                beq _done               ; strings are zero-terminated
.80b5	20 9c 80	jsr $809c	                jsr help_emit_a         ; allows vectoring via output
.80b8	c8		iny		                iny
.80b9	80 f6		bra $80b1	                bra _loop
.80bb					_done:
.80bb	60		rts		                rts
.80bc					help_print_string:
.80bc	20 a2 80	jsr $80a2	                jsr help_print_string_no_lf
.80bf	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.80c1	4c 9c 80	jmp $809c	                jmp help_emit_a         ; JSR/RTS

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../native-procedures.asm

.80c4					proc_char_whitespace_p:
.80c4					proc_newline:
.80c4	64 00		stz $00		                stz return
.80c6	64 01		stz $01		                stz return+1
.80c8	a9 0a		lda #$0a	                lda #AscLF
.80ca	4c 9c 80	jmp $809c	                jmp help_emit_a         ; JSR/RTS
.80cd					proc_display:
.80cd					proc_read:
.80cd					proc_read_char:
.80cd					proc_read_line:
.80cd					proc_write_char:

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../procedures.asm


;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../definitions.asm

=$03					        AscCC   = $03  ; break (CTRL-c)
=$07					        AscBELL = $07  ; bell sound
=$08					        AscBS   = $08  ; backspace
=$0a					        AscLF   = $0a  ; line feed
=$0d					        AscCR   = $0d  ; carriage return
=$1b					        AscESC  = $1b  ; escape
=$20					        AscSP   = $20  ; space
=$7f					        AscDEL  = $7f  ; delete (CTRL-h)
=$10					        AscCP   = $10  ; CTRL-p
=$0e					        AscCN   = $0e  ; CTRL-n
>0000					return:  .word ?     ; return value: result of a procedure
>0002					tmp0:    .word ?     ; temporary storage, eg printing
>0004					tmp1:    .word ?     ; temporary storage
>0006					tmp2:    .word ?     ; temporary storage
>0008					output:  .word ?     ; output port, addr of routine
>000a					input:   .word ?     ; input port, addr of routine
>000c					ciblen:  .word ?     ; current size of input buffer
>000e					hp:      .word ?     ; pointer to next free heap entry
>0200					cib0:    .fill cib_size      ; current input buffer

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../headers.asm

.80cd					h_newline:
>80cd	00 00				        .addr 0000              ; end of header list
>80cf	c4 80				        .addr proc_newline
>80d1	07				        .byte 7
>80d2	6e 65 77 6c 69 6e 65		        .text "newline"

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../strings.asm

=0					str_unspec = 0
.80d9					string_table:
>80d9	db 80				        .word s_unspec ; 0-4
>80db	3b 55 6e 73 70 65 63 69		s_unspec:       .null   ";Unspecified return value"     ; used eg with (display)
>80e3	66 69 65 64 20 72 65 74 75 72 6e 20 76 61 6c 75
>80f3	65 00

;******  Return to file: platforms/platform-py65mon.asm

>f000					.fill io_size                           ; Save space for the py65mon I/O
.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp cthulhu
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	43 74 68 75 6c 68 75 20		        .null "Cthulhu Scheme default kernel for py65mon (03. Apr 2020)", Asclf
>f034	53 63 68 65 6d 65 20 64 65 66 61 75 6c 74 20 6b
>f044	65 72 6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f
>f054	6e 20 28 30 33 2e 20 41 70 72 20 32 30 32 30 29
>f064	0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
