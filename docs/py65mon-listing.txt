
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output cthulhu-py65mon.bin platforms/platform-py65mon.asm
; Wed Apr 15 11:38:19 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platforms/platform-py65mon.asm

=true					DEBUG = true
=false					OCTAL = false
=$0000					ram_start = $0000       ; Start of RAM. Must contain the Zero Page
=$8000					ram_size  = $8000       ; assumes 32 KiB of RAM
=$0000					zp_start  = $0000       ; start of zero page,
=$80					zp_size   = $80         ; max bytes allowed in Zero Page
=$0200					buffers_start   = $0200         ; start of the buffer RAM area
=$100					cib_size        = $100          ; size of the input buffer, used by reader
=$100					tkb_size        = $100          ; size of the token buffer, used by lexer
=31744					heap_size       = ram_size - ($200+cib_size+tkb_size)
=$f000					io_start = $f000
=$10					io_size  = $10
=$8000					rom_start = $8000                       ; $8000 by default
=28672					rom_size = io_start - rom_start         ; $f000 - $8000 = $7000 (28 KiB)
=$fffa					vectors_start = $fffa
=$ffff					max_address   = $ffff

;******  Processing file: platforms/../cthulhu.asm

.8000					cthulhu:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 06		sta $06		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 07		sta $07		                sta output+1
.8009	a9 00		lda #$00	                lda <#heap
.800b	85 13		sta $13		                sta hp
.800d	a9 04		lda #$04	                lda >#heap
.800f	85 14		sta $14		                sta hp+1
.8011	64 15		stz $15		                stz symtbl
.8013	64 16		stz $16		                stz symtbl+1
.8015	64 17		stz $17		                stz strtbl
.8017	64 18		stz $18		                stz strtbl+1
.8019	64 19		stz $19		                stz bnmtbl
.801b	64 1a		stz $1a		                stz bnmtbl+1
.801d	64 1b		stz $1b		                stz ast
.801f	64 1c		stz $1c		                stz ast+1
.8021	a9 21		lda #$21	                lda #<kernel_getc
.8023	85 08		sta $08		                sta input
.8025	a9 f0		lda #$f0	                lda #>kernel_putc
.8027	85 09		sta $09		                sta input+1
.8029					repl:
.8029	64 0a		stz $0a		                stz ciblen
.802b	64 0b		stz $0b		                stz ciblen+1

;******  Processing file: platforms/../reader.asm

.802d					repl_read:
.802d	a0 00		ldy #$00	                ldy #0
.802f	64 0e		stz $0e		                stz input_f
.8031	a9 3e		lda #$3e	                lda #'>'
.8033	20 e5 83	jsr $83e5	                jsr help_emit_a
.8036	a9 20		lda #$20	                lda #' '
.8038	20 e5 83	jsr $83e5	                jsr help_emit_a
.803b					repl_read_loop:
.803b	20 e8 83	jsr $83e8	                jsr help_key_a
.803e	c9 3b		cmp #$3b	                cmp #$3B                ; semicolon
.8040	d0 0d		bne $804f	                bne _not_a_comment
.8042	20 e5 83	jsr $83e5	                jsr help_emit_a
.8045	aa		tax		                tax
.8046	a5 0e		lda $0e		                lda input_f
.8048	09 80		ora #$80	                ora #$80                ; Set bit 7
.804a	85 0e		sta $0e		                sta input_f
.804c	8a		txa		                txa
.804d	80 17		bra $8066	                bra _comment_continue
.804f					_not_a_comment:
.804f	c9 0a		cmp #$0a	                cmp #AscLF
.8051	f0 1b		beq $806e	                beq repl_read_eol
.8053	c9 0d		cmp #$0d	                cmp #AscCR
.8055	f0 17		beq $806e	                beq repl_read_eol
.8057	c9 08		cmp #$08	                cmp #AscBS
.8059	f0 38		beq $8093	                beq repl_read_backspace
.805b	c9 7f		cmp #$7f	                cmp #AscDEL             ; (CTRL-h)
.805d	f0 34		beq $8093	                beq repl_read_backspace
.805f	c9 04		cmp #$04	                cmp #$04
.8061	f0 20		beq $8083	                beq repl_input_end
.8063	20 e5 83	jsr $83e5	                jsr help_emit_a
.8066					_comment_continue:
.8066	99 00 02	sta $0200,y	                sta cib,y
.8069	c8		iny		                iny
.806a	c4 ff		cpy $ff		                cpy cib_size-1          ; reached character limit?
.806c	80 cd		bra $803b	                bra repl_read_loop      ; fall thru if buffer limit reached
.806e					repl_read_eol:
.806e	a6 0e		ldx $0e		                ldx input_f
.8070	10 3d		bpl $80af	                bpl repl_read_input_done
.8072	a9 0a		lda #$0a	                lda #AscLF              ; be safe, some send CR
.8074	20 e5 83	jsr $83e5	                jsr help_emit_a
.8077	99 00 02	sta $0200,y	                sta cib,y
.807a	c8		iny		                iny
.807b	a9 7f		lda #$7f	                lda #$7F
.807d	25 0e		and $0e		                and input_f
.807f	85 0e		sta $0e		                sta input_f
.8081	80 b8		bra $803b	                bra repl_read_loop
.8083					repl_input_end:
.8083	20 e3 83	jsr $83e3	                jsr help_emit_lf
.8086	a9 09		lda #$09	                lda #str_end_input
.8088	20 05 84	jsr $8405	                jsr help_print_string
.808b	a9 0a		lda #$0a	                lda #str_chant
.808d	20 05 84	jsr $8405	                jsr help_print_string
.8090	4c 2b f0	jmp $f02b	                jmp platform_quit
.8093					repl_read_backspace:
.8093	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8095	d0 06		bne $809d	                bne _skip_bell
.8097	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8099	20 e5 83	jsr $83e5	                jsr help_emit_a
.809c	c8		iny		                iny
.809d					_skip_bell:
.809d	88		dey		                dey
.809e	a9 08		lda #$08	                lda #AscBS      ; move back one
.80a0	20 e5 83	jsr $83e5	                jsr help_emit_a
.80a3	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.80a5	20 e5 83	jsr $83e5	                jsr help_emit_a
.80a8	a9 08		lda #$08	                lda #AscBS      ; move back over space
.80aa	20 e5 83	jsr $83e5	                jsr help_emit_a
.80ad	80 8c		bra $803b	                bra repl_read_loop
.80af					repl_read_input_done:
.80af					repl_read_buffer_full:
.80af	84 0a		sty $0a		                sty ciblen      ; Y contains number of chars accepted already
.80b1	a9 00		lda #$00	                lda #0
.80b3	85 0b		sta $0b		                sta ciblen+1    ; we only accept 256 chars
.80b5	99 00 02	sta $0200,y	                sta cib,y
.80b8	4c bb 80	jmp $80bb	                jmp lexer

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../lexer.asm

.80bb					lexer:
.80bb	20 5e 84	jsr $845e	                jsr debug_dump_input
.80be	a0 00		ldy #$00	                ldy #0
.80c0	64 0c		stz $0c		                stz cibp
.80c2	64 0d		stz $0d		                stz cibp+1      ; MSB currently unused
.80c4	64 11		stz $11		                stz tkbp
.80c6	64 12		stz $12		                stz tkbp+1      ; MSB currently unused
.80c8	98		tya		                tya
.80c9	19 00 02	ora $0200,y	                ora cib,y
.80cc	d0 03		bne $80d1	                bne lexer_loop
.80ce	4c c9 83	jmp $83c9	                jmp repl_done
.80d1					lexer_loop:
.80d1	b9 00 02	lda $0200,y	                lda cib,y
.80d4	c9 3b		cmp #$3b	                cmp #$3B                        ; semicolon
.80d6	d0 11		bne $80e9	                bne _no_comment
.80d8					_comment_loop:
.80d8	c8		iny		                iny
.80d9	b9 00 02	lda $0200,y	                lda cib,y
.80dc	c9 0a		cmp #$0a	                cmp #AscLF
.80de	f0 06		beq $80e6	                beq _comment_done
.80e0	c9 0d		cmp #$0d	                cmp #AscCR
.80e2	f0 02		beq $80e6	                beq _comment_done
.80e4	80 f2		bra $80d8	                bra _comment_loop
.80e6					_comment_done:
.80e6	4c aa 81	jmp $81aa	                jmp lexer_next
.80e9					_no_comment:
.80e9	20 1f 84	jsr $841f	                jsr help_is_whitespace
.80ec	90 03		bcc $80f1	                bcc _not_whitespace
.80ee	4c aa 81	jmp $81aa	                jmp lexer_next
.80f1					_not_whitespace:
.80f1					_test_parens:
.80f1					_test_done:
.80f1	d0 03		bne $80f6	                bne _not_done
.80f3	4c b2 81	jmp $81b2	                jmp lexer_end_of_input          ; not the same as lexer_done
.80f6					_not_done:
.80f6	c9 23		cmp #$23	                cmp #'#'
.80f8	f0 03		beq $80fd	                beq _got_sharp
.80fa	4c 9a 81	jmp $819a	                jmp lexer_not_sharp             ; too far for branch
.80fd					_got_sharp:
.80fd	c8		iny		                iny
.80fe	b9 00 02	lda $0200,y	                lda cib,y
.8101	c9 74		cmp #$74	                cmp #'t'                ; We're optimists so we check for true first
.8103	d0 08		bne $810d	                bne _not_true
.8105	a9 10		lda #$10	                lda #T_TRUE
.8107	20 ba 81	jsr $81ba	                jsr lexer_add_token
.810a	4c aa 81	jmp $81aa	                jmp lexer_next
.810d					_not_true:
.810d	c9 66		cmp #$66	                cmp #'f'
.810f	d0 08		bne $8119	                bne _not_false
.8111	a9 11		lda #$11	                lda #T_FALSE
.8113	20 ba 81	jsr $81ba	                jsr lexer_add_token
.8116	4c aa 81	jmp $81aa	                jmp lexer_next
.8119					_not_false:
.8119	c9 5c		cmp #$5c	                cmp #'\'
.811b	d0 00		bne $811d	                bne _no_backslash
.811d					_not_single_char:
.811d					_not_named_char:
.811d					_no_backslash:
.811d					_not_vector:
.811d	c9 78		cmp #$78	                        cmp #'x'        ; #x is hexadecimal
.811f	d0 04		bne $8125	                        bne _not_hexnum
.8121	a9 10		lda #$10	                        lda #$10        ; Base 16
.8123	80 13		bra $8138	                        bra lexer_got_number
.8125					_not_hexnum:
.8125	c9 62		cmp #$62	                        cmp #'b'        ; #b is binary
.8127	d0 04		bne $812d	                        bne _not_binnum
.8129	a9 02		lda #$02	                        lda #$02        ; Base 2
.812b	80 0b		bra $8138	                        bra lexer_got_number
.812d					_not_binnum:
.812d	c9 64		cmp #$64	                        cmp #'d'        ; #d is explicit decimal
.812f	d0 04		bne $8135	                        bne _illegal_radix
.8131	a9 0a		lda #$0a	                        lda #$0A        ; Base 10
.8133	80 03		bra $8138	                        bra lexer_got_number
.8135					_illegal_radix:
.8135	4c 92 81	jmp $8192	                        jmp lexer_illegal_radix
.8138					lexer_got_number:
.8138	48		pha		                        pha                     ; Save the radix for the moment
.8139	a9 12		lda #$12	                        lda #T_NUM_START
.813b	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.813e	68		pla		                        pla
.813f	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.8142	a6 11		ldx $11		                        ldx tkbp        ; get index of where length will be
.8144	86 00		stx $00		                        stx tmp0
.8146	a9 00		lda #$00	                        lda #0          ; dummy length value
.8148	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.814b	c8		iny		                        iny             ; Y is still the input buffer index
.814c	b9 00 02	lda $0200,y	                        lda cib,y
.814f	a2 00		ldx #$00	                        ldx #0          ; X counts length of string
.8151	c9 2d		cmp #$2d	                        cmp #'-'
.8153	d0 09		bne $815e	                        bne _check_for_plus
.8155	a9 ff		lda #$ff	                        lda #T_MINUS
.8157	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.815a	c8		iny		                        iny             ; skip minus character
.815b	e8		inx		                        inx             ; string now has length of 1
.815c	80 0b		bra $8169	                        bra _sign_done
.815e					_check_for_plus:
.815e	c9 2b		cmp #$2b	                        cmp #'+'
.8160	d0 01		bne $8163	                        bne _default_plus
.8162	c8		iny		                        iny
.8163					_default_plus:
.8163	a9 ee		lda #$ee	                        lda #T_PLUS
.8165	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.8168	e8		inx		                        inx             ; string now has length of 1
.8169					_sign_done:
.8169	b9 00 02	lda $0200,y	                        lda cib,y
.816c	f0 24		beq $8192	                        beq lexer_terminator_too_early  ; 00 terminates input
.816e	20 19 84	jsr $8419	                        jsr help_is_delimiter
.8171	b0 1f		bcs $8192	                        bcs lexer_delimiter_too_early
.8173					_number_loop:
.8173	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.8176	e8		inx		                        inx             ; String one character longer
.8177	c8		iny		                        iny             ; Next character
.8178	b9 00 02	lda $0200,y	                        lda cib,y
.817b	f0 07		beq $8184	                        beq _legal_terminator
.817d	20 19 84	jsr $8419	                        jsr help_is_delimiter
.8180	b0 02		bcs $8184	                        bcs _number_done
.8182	80 ef		bra $8173	                        bra _number_loop
.8184					_legal_terminator:
.8184					_number_done:
.8184	a9 82		lda #$82	                        lda #T_NUM_END
.8186	20 ba 81	jsr $81ba	                        jsr lexer_add_token
.8189	8a		txa		                        txa             ; number of chars was in X
.818a	a6 00		ldx $00		                        ldx tmp0        ; index of length byte in token stream
.818c	9d 00 03	sta $0300,x	                        sta tkb,x
.818f	4c ab 81	jmp $81ab	                        jmp lexer_next_same_char
.8192					lexer_illegal_radix:
.8192					lexer_terminator_too_early:
.8192					lexer_delimiter_too_early:
.8192	a9 06		lda #$06	                lda #str_bad_number
.8194	20 05 84	jsr $8405	                jsr help_print_string
.8197	4c 29 80	jmp $8029	                jmp repl
.819a					lexer_not_octnum
.819a					lexer_not_sharp:
.819a					_not_decnum:
.819a					_not_string:
.819a					lexer_error:
.819a	48		pha		                pha
.819b	a9 00		lda #$00	                lda #str_unbound
.819d	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.81a0	68		pla		                pla
.81a1	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.81a4	20 e3 83	jsr $83e3	                jsr help_emit_lf
.81a7	4c 29 80	jmp $8029	                jmp repl
.81aa					lexer_next:
.81aa	c8		iny		                iny
.81ab					lexer_next_same_char:
.81ab	c4 0a		cpy $0a		                cpy ciblen
.81ad	f0 03		beq $81b2	                beq lexer_end_of_input
.81af	4c d1 80	jmp $80d1	                jmp lexer_loop
.81b2					lexer_end_of_input:
.81b2	a9 00		lda #$00	                lda #T_END
.81b4	20 ba 81	jsr $81ba	                jsr lexer_add_token
.81b7	4c c5 81	jmp $81c5	                jmp lexer_done
.81ba					lexer_add_token:
.81ba	5a		phy		                phy             ; Could also store in cibp
.81bb	a4 11		ldy $11		                ldy tkbp
.81bd	99 00 03	sta $0300,y	                sta tkb,y       ; LSB is in A
.81c0	c8		iny		                iny
.81c1	84 11		sty $11		                sty tkbp
.81c3	7a		ply		                ply
.81c4	60		rts		                rts
=$00					T_END           = $00
=$01					T_PAREN_OPEN    = $01   ; '('
=$02					T_PAREN_CLOSED  = $02   ; ')'
=$03					T_SHARP         = $03   ; '#' - note '#f', '#t' and others are precprocessed
=$10					T_TRUE       = $10   ; '#t'
=$11					T_FALSE      = $11   ; '#f'
=$12					T_NUM_START  = $12   ; Marks beginning of a number sequence
=$82					T_NUM_END    = $82   ; Marks end of a number sequence, see T_NUM_START
=$ee					T_PLUS       = $EE   ; Also used in number token sequence
=$ff					T_MINUS      = $FF   ; Also used in number token sequence
.81c5					lexer_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../parser.asm

.81c5					parser:
.81c5	20 7b 84	jsr $847b	                jsr debug_dump_token
.81c8	64 1b		stz $1b		                stz ast
.81ca	64 1c		stz $1c		                stz ast+1
.81cc	64 11		stz $11		                stz tkbp
.81ce	64 12		stz $12		                stz tkbp+1      ; fake, currently only using LSB
.81d0	a9 1b		lda #$1b	                lda <#ast
.81d2	85 1d		sta $1d		                sta astp
.81d4	a9 00		lda #$00	                lda >#ast       ; paranoid, MSB always 00 for zero page
.81d6	85 1e		sta $1e		                sta astp+1
.81d8	a2 ff		ldx #$ff	                ldx #$FF
.81da					parser_loop:
.81da	e8		inx		                inx
.81db	bd 00 03	lda $0300,x	                lda tkb,x
.81de					_end_token:
.81de	c9 00		cmp #$00	                cmp #T_END
.81e0	d0 03		bne $81e5	                bne _not_end_token
.81e2	4c 10 83	jmp $8310	                jmp parser_done
.81e5					_not_end_token:
.81e5	c9 10		cmp #$10	                cmp #T_TRUE
.81e7	d0 0a		bne $81f3	                bne _not_true_token
.81e9	a9 ff		lda #$ff	                lda <#OC_TRUE
.81eb	a0 1f		ldy #$1f	                ldy >#OC_TRUE
.81ed	20 ce 82	jsr $82ce	                jsr parser_add_object
.81f0	4c da 81	jmp $81da	                jmp parser_loop
.81f3					_not_true_token:
.81f3	c9 11		cmp #$11	                cmp #T_FALSE
.81f5	d0 0a		bne $8201	                bne _not_false_token
.81f7	a9 00		lda #$00	                lda <#OC_FALSE
.81f9	a0 10		ldy #$10	                ldy >#OC_FALSE
.81fb	20 ce 82	jsr $82ce	                jsr parser_add_object
.81fe	4c da 81	jmp $81da	                jmp parser_loop
.8201					_not_false_token:
.8201	c9 12		cmp #$12	                cmp #T_NUM_START
.8203	f0 03		beq $8208	                beq +
.8205	4c ae 82	jmp $82ae	                jmp parser_not_num              ; Too far for BRA
.8208					+
.8208	64 02		stz $02		                stz tmp1
.820a	64 03		stz $03		                stz tmp1+1
.820c	e8		inx		                inx                     ; skip over T_NUM_START TOKEN
.820d	bd 00 03	lda $0300,x	                lda tkb,x
.8210	85 00		sta $00		                sta tmp0        ; radix
.8212	e8		inx		                inx
.8213	bd 00 03	lda $0300,x	                lda tkb,x
.8216	a8		tay		                tay             ; we need the length of the string later ...
.8217	88		dey		                dey             ; ... but we don't need to include the sign
.8218	e8		inx		                inx             ; Move to token for sign, T_PLUS or T_MINUS
.8219	bd 00 03	lda $0300,x	                lda tkb,x
.821c	85 01		sta $01		                sta tmp0+1      ; Just store sign for now
.821e	e8		inx		                inx
.821f	a5 00		lda $00		                lda tmp0        ; radix
.8221	c9 0a		cmp #$0a	                cmp #$0a
.8223	d0 03		bne $8228	                bne _not_dec
.8225	4c 96 82	jmp $8296	                jmp parser_common_fixnum
.8228					_not_dec:
.8228	c9 10		cmp #$10	                cmp #$10
.822a	d0 36		bne $8262	                bne _not_hex
.822c	98		tya		                tya
.822d	c9 04		cmp #$04	                cmp #$04
.822f	90 03		bcc $8234	                bcc _dec_fixnum
.8231	4c c6 82	jmp $82c6	                jmp function_not_available
.8234					_dec_fixnum:
.8234					_hex_fixnum_loop:
.8234	bd 00 03	lda $0300,x	                lda tkb,x
.8237	c9 82		cmp #$82	                cmp #T_NUM_END
.8239	f0 24		beq $825f	                beq _done_hex
.823b	20 36 84	jsr $8436	                jsr help_hexascii_to_value
.823e	10 03		bpl $8243	                bpl _legal_hex_digit
.8240	4c be 82	jmp $82be	                jmp parser_bad_digit
.8243					_legal_hex_digit:
.8243	0a		asl a		                asl
.8244	0a		asl a		                asl
.8245	0a		asl a		                asl
.8246	0a		asl a		                asl
.8247	2a		rol a		                rol             ; bit 7 of A now in carry flag
.8248	26 03		rol $03		                rol tmp1+1      ; bit 7 of tmp1+1 now in carry flag
.824a	26 02		rol $02		                rol tmp1        ; now is bit 0 of tmp1
.824c	2a		rol a		                rol
.824d	26 03		rol $03		                rol tmp1+1
.824f	26 02		rol $02		                rol tmp1
.8251	2a		rol a		                rol
.8252	26 03		rol $03		                rol tmp1+1
.8254	26 02		rol $02		                rol tmp1
.8256	2a		rol a		                rol
.8257	26 03		rol $03		                rol tmp1+1
.8259	26 02		rol $02		                rol tmp1
.825b	e8		inx		                inx
.825c	88		dey		                dey
.825d	d0 d5		bne $8234	                bne _hex_fixnum_loop
.825f					_done_hex:
.825f	4c 96 82	jmp $8296	                jmp parser_common_fixnum
.8262					_not_hex:
.8262	c9 02		cmp #$02	                cmp #$02
.8264	d0 28		bne $828e	                bne _not_binary
.8266	98		tya		                tya
.8267	c9 0d		cmp #$0d	                cmp #$0D                ; "smaller than 13"
.8269	90 03		bcc $826e	                bcc _bin_fixnum
.826b	4c c6 82	jmp $82c6	                jmp function_not_available
.826e					_bin_fixnum:
.826e					_bin_fixnum_loop:
.826e	bd 00 03	lda $0300,x	                lda tkb,x
.8271	c9 30		cmp #$30	                cmp #'0'
.8273	f0 0b		beq $8280	                beq _legal_bit_char
.8275	c9 31		cmp #$31	                cmp #'1'
.8277	f0 07		beq $8280	                beq _legal_bit_char
.8279	c9 82		cmp #$82	                cmp #T_NUM_END
.827b	f0 0e		beq $828b	                beq _done_bin
.827d	4c be 82	jmp $82be	                jmp parser_bad_digit
.8280					_legal_bit_char:
.8280	29 01		and #$01	                and #$01                ; gives us $00 or $01
.8282	6a		ror a		                ror                     ; push the bit into carry flag
.8283	26 03		rol $03		                rol tmp1+1              ; rotate the carry flag into LSB ...
.8285	26 02		rol $02		                rol tmp1                ; ... and highest bit of tmp1+1 to tmp1
.8287	e8		inx		                inx
.8288	88		dey		                dey
.8289	d0 e3		bne $826e	                bne _bin_fixnum_loop    ; Repeat till we're done
.828b					_done_bin:
.828b	4c 96 82	jmp $8296	                jmp parser_common_fixnum
.828e					_not_binary:
.828e					_illegal_radix:
.828e	48		pha		                pha                             ; save the evil radix
.828f	a9 07		lda #$07	                lda #str_bad_radix
.8291	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.8294	80 1e		bra $82b4	                bra parser_common_panic         ; prints offending byte and LF
.8296					parser_common_fixnum:
.8296	a5 01		lda $01		                lda tmp0+1
.8298	c9 ff		cmp #$ff	                cmp #T_MINUS
.829a	f0 08		beq $82a4	                beq _negative_number
.829c	a9 20		lda #$20	                lda #OT_FIXNUM
.829e	05 02		ora $02		                ora tmp1
.82a0	85 02		sta $02		                sta tmp1
.82a2	80 00		bra $82a4	                bra _add_fixnum_to_ast
.82a4					_negative_number:
.82a4					_add_fixnum_to_ast:
.82a4	a5 03		lda $03		                lda tmp1+1
.82a6	a4 02		ldy $02		                ldy tmp1
.82a8	20 ce 82	jsr $82ce	                jsr parser_add_object
.82ab					_num_end:
.82ab	4c da 81	jmp $81da	                jmp parser_loop
.82ae					parser_not_num:
.82ae					paser_bad_token:
.82ae	48		pha		                pha                             ; save the evil token
.82af	a9 04		lda #$04	                lda #str_bad_token
.82b1	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.82b4					parser_common_panic:
.82b4	68		pla		                pla
.82b5	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii          ; print bad token as hex number
.82b8	20 e3 83	jsr $83e3	                jsr help_emit_lf
.82bb	4c 29 80	jmp $8029	                jmp repl
.82be					parser_bad_digit:
.82be	48		pha		                pha
.82bf	a9 06		lda #$06	                lda #str_bad_number
.82c1	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.82c4	80 ee		bra $82b4	                bra parser_common_panic
.82c6					function_not_available:
.82c6	a9 08		lda #$08	                lda #str_cant_yet
.82c8	20 05 84	jsr $8405	                jsr help_print_string
.82cb	4c 29 80	jmp $8029	                jmp repl
.82ce					parser_add_object:
.82ce	da		phx		                phx             ; save index to token buffer
.82cf	5a		phy		                phy             ; save MSB of the object
.82d0	48		pha		                pha             ; save LSB of the object
.82d1	a5 13		lda $13		                lda hp
.82d3	85 00		sta $00		                sta tmp0
.82d5	a5 14		lda $14		                lda hp+1
.82d7	85 01		sta $01		                sta tmp0+1
.82d9	a9 00		lda #$00	                lda <#OC_END
.82db	a0 00		ldy #$00	                ldy #0
.82dd	91 13		sta ($13),y	                sta (hp),y
.82df	c8		iny		                iny
.82e0	a9 00		lda #$00	                lda >#OC_END
.82e2	91 13		sta ($13),y	                sta (hp),y
.82e4	c8		iny		                iny
.82e5	68		pla		                pla             ; retrieve LSB
.82e6	91 13		sta ($13),y	                sta (hp),y
.82e8	c8		iny		                iny
.82e9	68		pla		                pla             ; retrieve MSB, was in Y
.82ea	91 13		sta ($13),y	                sta (hp),y
.82ec	c8		iny		                iny
.82ed	a9 00		lda #$00	                lda #0
.82ef	91 13		sta ($13),y	                sta (hp),y
.82f1	c8		iny		                iny
.82f2	91 13		sta ($13),y	                sta (hp),y
.82f4	c8		iny		                iny
.82f5	98		tya		                tya
.82f6	18		clc		                clc
.82f7	65 13		adc $13		                adc hp
.82f9	85 13		sta $13		                sta hp
.82fb	90 02		bcc $82ff	                bcc +
.82fd	e6 14		inc $14		                inc hp+1
.82ff					+
.82ff	a5 00		lda $00		                lda tmp0        ; original LSB of hp
.8301	aa		tax		                tax             ; We'll need it again in a second
.8302	92 1d		sta ($1d)	                sta (astp)
.8304	a0 01		ldy #$01	                ldy #1
.8306	a5 01		lda $01		                lda tmp0+1      ; original MSB of hp
.8308	91 1d		sta ($1d),y	                sta (astp),y
.830a	85 1e		sta $1e		                sta astp+1      ; MSB, was tmp0+1
.830c	86 1d		stx $1d		                stx astp        ; LSB, was tmp0
.830e	fa		plx		                plx             ; get back index for token buffer
.830f	60		rts		                rts
=$0000					OC_END   = $0000        ; end of input for AST
=$1fff					OC_TRUE  = $1fff        ; true bool #t, immediate
=$1000					OC_FALSE = $1000        ; false bool #f, immediate
.8310					parser_done:
.8310	a9 00		lda #$00	                lda <#OC_END
.8312	a2 00		ldx #$00	                ldx >#OC_END
.8314	20 ce 82	jsr $82ce	                jsr parser_add_object

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../eval.asm

.8317					eval:
.8317	20 ae 84	jsr $84ae	                jsr debug_dump_ast
.831a	20 9c 84	jsr $849c	                jsr debug_dump_hp
.831d	a5 1b		lda $1b		                lda ast
.831f	85 02		sta $02		                sta tmp1
.8321	a5 1c		lda $1c		                lda ast+1
.8323	85 03		sta $03		                sta tmp1+1
.8325					eval_loop:
.8325	a0 03		ldy #$03	                ldy #3          ; MSB of the next node entry down ...
.8327	b1 02		lda ($02),y	                lda (tmp1),y    ; ...  which contains the tag nibble
.8329	29 f0		and #$f0	                and #$f0        ; mask all but tag nibble
.832b	4a		lsr a		                lsr
.832c	4a		lsr a		                lsr
.832d	4a		lsr a		                lsr             ; Fourth LSR and ASL cancle each other
.832e	aa		tax		                tax
.832f	7c 3f 83	jmp ($833f,x)	                jmp (eval_table,X)
.8332					eval_next:
.8332	b2 02		lda ($02)	                lda (tmp1)              ; LSB of next entry
.8334	aa		tax		                tax
.8335	a0 01		ldy #$01	                ldy #1
.8337	b1 02		lda ($02),y	                lda (tmp1),y            ; MSB of next entry
.8339	85 03		sta $03		                sta tmp1+1
.833b	86 02		stx $02		                stx tmp1
.833d	80 e6		bra $8325	                bra eval_loop
.833f					eval_0_meta:
.833f					eval_1_bool:
.833f					eval_2_fixnum:
.833f					eval_3_bignum:
.833f					eval_4_char:
.833f					eval_5_strings:
.833f					eval_6_UNDEFINED:
.833f					eval_7_UNDEFINED:
.833f					eval_8_UNDEFINED:
.833f					eval_9_UNDEFINED:
.833f					eval_A_UNDEFINED:
.833f					eval_B_UNDEFINED:
.833f					eval_C_UNDEFINED:
.833f					eval_D_UNDEFINED:
.833f					eval_E_UNDEFINED:
.833f					eval_F_UNDEFINED:
.833f					eval_table:
>833f	5f 83 32 83 32 83 32 83		        .word eval_done, eval_next, eval_next, eval_next
>8347	32 83 32 83 32 83 32 83		        .word eval_next, eval_next, eval_next, eval_next
>834f	32 83 32 83 32 83 32 83		        .word eval_next, eval_next, eval_next, eval_next
>8357	32 83 32 83 32 83 32 83		        .word eval_next, eval_next, eval_next, eval_next
.835f					eval_done:

;******  Return to file: platforms/../cthulhu.asm


;******  Processing file: platforms/../printer.asm

.835f					printer:
.835f	a5 1b		lda $1b		                lda ast
.8361	85 02		sta $02		                sta tmp1
.8363	a5 1c		lda $1c		                lda ast+1
.8365	85 03		sta $03		                sta tmp1+1
.8367					printer_loop:
.8367	20 e3 83	jsr $83e3	                jsr help_emit_lf
.836a	a0 03		ldy #$03	                ldy #3                  ; MSB of the next node entry down ...
.836c	b1 02		lda ($02),y	                lda (tmp1),y            ; ...  which contains the tag nibble
.836e	29 f0		and #$f0	                and #$f0                ; mask all but tag nibble
.8370					_check_for_meta:
.8370	c9 00		cmp #$00	                cmp #OT_META
.8372	d0 07		bne $837b	                bne _not_meta
.8374	12 02		ora ($02)	                ora (tmp1)              ; LSB
.8376	d0 30		bne $83a8	                bne printer_error       ; We're in trouble, panic and re-REPL
.8378	4c c9 83	jmp $83c9	                jmp printer_done
.837b					_not_meta:
.837b	c9 10		cmp #$10	                cmp #OT_BOOL
.837d	d0 12		bne $8391	                bne _not_bool
.837f	a0 02		ldy #$02	                ldy #2
.8381	b1 02		lda ($02),y	                lda (tmp1),y            ; LSB
.8383	d0 04		bne $8389	                bne _bool_true          ; not a zero means true
.8385	a9 03		lda #$03	                lda #str_false
.8387	80 02		bra $838b	                bra _bool_printer
.8389					_bool_true:
.8389	a9 02		lda #$02	                lda #str_true
.838b					_bool_printer:
.838b	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.838e	4c bb 83	jmp $83bb	                jmp printer_next
.8391					_not_bool:
.8391	c9 20		cmp #$20	                cmp #OT_FIXNUM
.8393	d0 13		bne $83a8	                bne _not_fixnum
.8395	a0 03		ldy #$03	                ldy #3          ; tag nibble and high nibble of number
.8397	b1 02		lda ($02),y	                lda (tmp1),y    ; MSB nibble
.8399	29 0f		and #$0f	                and #$0F        ; Mask tab
.839b	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.839e	a0 02		ldy #$02	                ldy #2
.83a0	b1 02		lda ($02),y	                lda (tmp1),y    ; LSB
.83a2	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.83a5	4c bb 83	jmp $83bb	                jmp printer_next
.83a8					_not_fixnum:
.83a8					printer_error:
.83a8	a5 05		lda $05		                lda str_bad_object
.83aa	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.83ad	a0 01		ldy #$01	                ldy #1
.83af	b1 02		lda ($02),y	                lda (tmp1),y
.83b1	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.83b4	b2 02		lda ($02)	                lda (tmp1)
.83b6	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.83b9	80 0e		bra $83c9	                bra printer_done
.83bb					printer_next:
.83bb	b2 02		lda ($02)	                lda (tmp1)              ; LSB of next entry
.83bd	aa		tax		                tax
.83be	a0 01		ldy #$01	                ldy #1
.83c0	b1 02		lda ($02),y	                lda (tmp1),y            ; MSB of next entry
.83c2	85 03		sta $03		                sta tmp1+1
.83c4	86 02		stx $02		                stx tmp1
.83c6	4c 67 83	jmp $8367	                jmp printer_loop
.83c9					printer_done:

;******  Return to file: platforms/../cthulhu.asm

.83c9					repl_done:
.83c9	4c 29 80	jmp $8029	                jmp repl

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../helpers.asm

.83cc					help_byte_to_ascii:
.83cc	48		pha		                pha
.83cd	4a		lsr a		                lsr             ; convert high nibble first
.83ce	4a		lsr a		                lsr
.83cf	4a		lsr a		                lsr
.83d0	4a		lsr a		                lsr
.83d1	20 d5 83	jsr $83d5	                jsr help_nibble_to_ascii
.83d4	68		pla		                pla
.83d5					help_nibble_to_ascii:
.83d5	29 0f		and #$0f	                and #$0F
.83d7	09 30		ora #$30	                ora #'0'
.83d9	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.83db	90 02		bcc $83df	                bcc +
.83dd	69 06		adc #$06	                adc #$06
.83df	4c e5 83	jmp $83e5	+               jmp help_emit_a       ; JSR/RTS
.83e2					help_to_lowercase:
.83e2	60		rts		                rts
.83e3					help_emit_lf:
.83e3	a9 0a		lda #$0a	                lda #AscLF
.83e5					help_emit_a:
.83e5	6c 06 00	jmp ($0006)	                jmp (output)    ; JSR/RTS
.83e8					help_key_a:
.83e8	6c 08 00	jmp ($0008)	                jmp (input)             ; JSR/RTS
.83eb					help_print_string_no_lf:
.83eb	0a		asl a		                asl
.83ec	a8		tay		                tay
.83ed	b9 82 85	lda $8582,y	                lda string_table,y
.83f0	85 00		sta $00		                sta tmp0                ; LSB
.83f2	c8		iny		                iny
.83f3	b9 82 85	lda $8582,y	                lda string_table,y
.83f6	85 01		sta $01		                sta tmp0+1              ; MSB
.83f8					help_print_common:
.83f8	a0 00		ldy #$00	                ldy #0
.83fa					_loop:
.83fa	b1 00		lda ($00),y	                lda (tmp0),y
.83fc	f0 06		beq $8404	                beq _done               ; strings are zero-terminated
.83fe	20 e5 83	jsr $83e5	                jsr help_emit_a         ; allows vectoring via output
.8401	c8		iny		                iny
.8402	80 f6		bra $83fa	                bra _loop
.8404					_done:
.8404	60		rts		                rts
.8405					help_print_string:
.8405	20 eb 83	jsr $83eb	                jsr help_print_string_no_lf
.8408	a9 0a		lda #$0a	                lda #AscLF              ; we don't use (newline) because of string
.840a	4c e5 83	jmp $83e5	                jmp help_emit_a         ; JSR/RTS
.840d					help_is_decdigit:
.840d	c9 30		cmp #$30	                cmp #'0'
.840f	90 07		bcc $8418	                bcc _below_zero         ; A is < '0'
.8411	c9 3a		cmp #$3a	                cmp #':'                ; A is >= ':', which is '9'+1
.8413	b0 02		bcs $8417	                bcs _above_nine
.8415	38		sec		                sec
.8416	60		rts		                rts
.8417					_above_nine:
.8417	18		clc		                clc
.8418					_below_zero:
.8418	60		rts		                rts
.8419					help_is_delimiter:
.8419	20 1f 84	jsr $841f	                jsr help_is_whitespace
.841c	b0 00		bcs $841e	                bcs _delimiter_done
.841e					_delimiter_done:
.841e	60		rts		                rts
.841f					help_is_whitespace:
.841f	38		sec		                sec             ; default is whitespace
.8420	c9 20		cmp #$20	                cmp #$20        ; SPACE, assumed to be the most common char
.8422	f0 11		beq $8435	                beq _done
.8424	c9 09		cmp #$09	                cmp #$09        ; TAB, probably the second most common in Scheme
.8426	f0 0d		beq $8435	                beq _done
.8428	c9 0a		cmp #$0a	                cmp #$0A        ; Linefeed, normally ends input but not with Scheme
.842a	f0 09		beq $8435	                beq _done
.842c	c9 0d		cmp #$0d	                cmp #$0D        ; Return, normally ends input but not with Scheme
.842e	f0 05		beq $8435	                beq _done
.8430	c9 0c		cmp #$0c	                cmp #$0C        ; Page, which is strange, but in the standard
.8432	f0 01		beq $8435	                beq _done
.8434	18		clc		                clc             ; If we end up here, it's not whitespace
.8435					_done:
.8435	60		rts		                rts
.8436					help_hexascii_to_value:
.8436	20 0d 84	jsr $840d	                jsr help_is_decdigit
.8439	90 05		bcc $8440	                bcc _see_if_letter
.843b	38		sec		                sec
.843c	e9 30		sbc #$30	                sbc #'0'
.843e	80 0f		bra $844f	                bra _done
.8440					_see_if_letter:
.8440	c9 41		cmp #$41	                cmp #'A'        ; lower than 'A' can't be right
.8442	90 17		bcc $845b	                bcc _error
.8444	c9 67		cmp #$67	                cmp #'g'        ; 'g' or above can't be right
.8446	b0 13		bcs $845b	                bcs _error
.8448	c9 61		cmp #$61	                cmp #'a'
.844a	90 06		bcc $8452	                bcc _uppercase
.844c	38		sec		                sec
.844d	e9 47		sbc #$47	                sbc #71         ; moves 'a' to 10 ($0A)
.844f					_done:
.844f	29 0f		and #$0f	                and #$0F        ; paranoid
.8451	60		rts		                rts
.8452					_uppercase:
.8452	c9 47		cmp #$47	                cmp #'G'
.8454	b0 05		bcs $845b	                bcs _error
.8456	38		sec		                sec
.8457	e9 37		sbc #$37	                sbc #55         ; moves 'A' to 10 ($0A)
.8459	80 f4		bra $844f	                bra _done
.845b					_error:
.845b	a9 80		lda #$80	                lda #$80
.845d	60		rts		                rts

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../native-procedures.asm

.845e					proc_char_whitespace_p:
.845e					proc_newline:
.845e					proc_display:
.845e					proc_read:
.845e					proc_read_char:
.845e					proc_read_line:
.845e					proc_write_char:

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../procedures.asm


;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../debug.asm

.845e					debug_dump_input:
.845e	20 e3 83	jsr $83e3	                jsr help_emit_lf
.8461	a9 03		lda #$03	                lda #strd_dump_input            ; "Input: "
.8463	20 1b 85	jsr $851b	                jsr debug_print_string_no_lf
.8466	a2 00		ldx #$00	                ldx #0
.8468					-
.8468	bd 00 02	lda $0200,x	                lda cib,x
.846b	f0 0b		beq $8478	                beq _done
.846d	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.8470	e8		inx		                inx
.8471	a9 20		lda #$20	                lda #' '
.8473	20 e5 83	jsr $83e5	                jsr help_emit_a
.8476	80 f0		bra $8468	                bra -
.8478					_done:
.8478	4c cc 83	jmp $83cc	                jmp help_byte_to_ascii          ; JSR/RTS
.847b					debug_dump_token:
.847b	20 e3 83	jsr $83e3	                jsr help_emit_lf
.847e	a9 00		lda #$00	                lda #strd_dump_token            ; "Token: "
.8480	20 1b 85	jsr $851b	                jsr debug_print_string_no_lf
.8483	a2 00		ldx #$00	                ldx #0
.8485					-
.8485	bd 00 03	lda $0300,x	                lda tkb,x
.8488	c9 00		cmp #$00	                cmp #T_END
.848a	f0 0d		beq $8499	                beq _done
.848c	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.848f	e8		inx		                inx
.8490	a9 20		lda #$20	                lda #' '
.8492	20 e5 83	jsr $83e5	                jsr help_emit_a
.8495	e4 11		cpx $11		                cpx tkbp
.8497	d0 ec		bne $8485	                bne -
.8499					_done:
.8499	4c cc 83	jmp $83cc	                jmp help_byte_to_ascii          ; JSR/RTS
.849c					debug_dump_hp:
.849c	20 e3 83	jsr $83e3	                jsr help_emit_lf
.849f	a9 02		lda #$02	                lda #strd_dump_hp               ; "Heap pointer: "
.84a1	20 1b 85	jsr $851b	                jsr debug_print_string_no_lf
.84a4	a5 14		lda $14		                lda hp+1
.84a6	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84a9	a5 13		lda $13		                lda hp
.84ab	4c cc 83	jmp $83cc	                jmp help_byte_to_ascii          ; JSR/RTS
.84ae					debug_dump_ast:
.84ae	20 e3 83	jsr $83e3	                jsr help_emit_lf
.84b1	a9 01		lda #$01	                lda #strd_dump_ast              ; "AST: "
.84b3	20 1b 85	jsr $851b	                jsr debug_print_string_no_lf
.84b6	a5 1c		lda $1c		                lda ast+1
.84b8	85 03		sta $03		                sta tmp1+1
.84ba	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84bd	a5 1b		lda $1b		                lda ast
.84bf	85 02		sta $02		                sta tmp1
.84c1	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84c4					_loop:
.84c4	a9 20		lda #$20	                lda #' '
.84c6	20 e5 83	jsr $83e5	                jsr help_emit_a
.84c9	a0 01		ldy #$01	                ldy #1
.84cb	b1 02		lda ($02),y	                lda (tmp1),y
.84cd	85 05		sta $05		                sta tmp2+1
.84cf	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii          ; MSB
.84d2	b2 02		lda ($02)	                lda (tmp1)
.84d4	85 04		sta $04		                sta tmp2                        ; pointer to next entry, LSB
.84d6	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii          ; LSB
.84d9	a9 3a		lda #$3a	                lda #':'
.84db	20 e5 83	jsr $83e5	                jsr help_emit_a
.84de	a0 03		ldy #$03	                ldy #3
.84e0	b1 02		lda ($02),y	                lda (tmp1),y
.84e2	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84e5	a0 02		ldy #$02	                ldy #2
.84e7	b1 02		lda ($02),y	                lda (tmp1),y
.84e9	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84ec	a9 3a		lda #$3a	                lda #':'
.84ee	20 e5 83	jsr $83e5	                jsr help_emit_a
.84f1	a0 05		ldy #$05	                ldy #5
.84f3	b1 02		lda ($02),y	                lda (tmp1),y
.84f5	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84f8	a0 04		ldy #$04	                ldy #4
.84fa	b1 02		lda ($02),y	                lda (tmp1),y
.84fc	20 cc 83	jsr $83cc	                jsr help_byte_to_ascii
.84ff	a5 04		lda $04		                lda tmp2
.8501	05 05		ora $05		                ora tmp2+1      ; Cheating: We know that OC_END is 0000
.8503	f0 0a		beq $850f	                beq _done
.8505	a5 04		lda $04		                lda tmp2
.8507	85 02		sta $02		                sta tmp1
.8509	a5 05		lda $05		                lda tmp2+1
.850b	85 03		sta $03		                sta tmp1+1
.850d	80 b5		bra $84c4	                bra _loop
.850f					_done:
.850f	60		rts		                rts
.8510					debug_emit_a:
.8510	48		pha		                pha
.8511	20 e3 83	jsr $83e3	                jsr help_emit_lf
.8514	68		pla		                pla
.8515	20 e5 83	jsr $83e5	                jsr help_emit_a
.8518	4c e3 83	jmp $83e3	                jmp help_emit_lf        ; JSR/RTS
.851b					debug_print_string_no_lf:
.851b	0a		asl a		                asl
.851c	a8		tay		                tay
.851d	b9 6e 85	lda $856e,y	                lda sd_table,y
.8520	85 00		sta $00		                sta tmp0                ; LSB
.8522	c8		iny		                iny
.8523	b9 6e 85	lda $856e,y	                lda sd_table,y
.8526	85 01		sta $01		                sta tmp0+1              ; MSB
.8528					debug_print_common:
.8528	a0 00		ldy #$00	                ldy #0
.852a					_loop:
.852a	b1 00		lda ($00),y	                lda (tmp0),y
.852c	f0 06		beq $8534	                beq _done               ; strings are zero-terminated
.852e	20 e5 83	jsr $83e5	                jsr help_emit_a         ; allows vectoring via output
.8531	c8		iny		                iny
.8532	80 f6		bra $852a	                bra _loop
.8534					_done:
.8534	60		rts		                rts
.8535					debug_print_string:
.8535	20 1b 85	jsr $851b	                jsr debug_print_string_no_lf
.8538	4c e3 83	jmp $83e3	                jmp help_emit_lf        ; JSR/RTS
=0					strd_dump_token = 0
=1					strd_dump_ast   = 1
=2					strd_dump_hp    = 2
=3					strd_dump_input = 3
>853b	54 6f 6b 65 6e 20 42 75		s_dump_token:   .null   "Token Buffer: "
>8543	66 66 65 72 3a 20 00
>854a	41 53 54 3a 20 00		s_dump_ast:     .null   "AST: "
>8550	48 65 61 70 20 70 6f 69		s_dump_hp:      .null   "Heap pointer: "
>8558	6e 74 65 72 3a 20 00
>855f	49 6e 70 75 74 20 42 75		s_dump_input:   .null   "Input Buffer: "
>8567	66 66 65 72 3a 20 00
.856e					sd_table:
>856e	3b 85 4a 85 50 85 5f 85		        .word s_dump_token, s_dump_ast, s_dump_hp, s_dump_input      ; 0-3

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../definitions.asm

=$03					        AscCC   = $03  ; break (CTRL-c)
=$07					        AscBELL = $07  ; bell sound
=$08					        AscBS   = $08  ; backspace
=$0a					        AscLF   = $0a  ; line feed
=$0d					        AscCR   = $0d  ; carriage return
=$1b					        AscESC  = $1b  ; escape
=$20					        AscSP   = $20  ; space
=$7f					        AscDEL  = $7f  ; delete (CTRL-h)
>0000					tmp0:    .word ?     ; temporary storage, eg printing
>0002					tmp1:    .word ?     ; temporary storage
>0004					tmp2:    .word ?     ; temporary storage
>0006					output:  .word ?     ; output port, addr of routine
>0008					input:   .word ?     ; input port, addr of routine
>000a					ciblen:  .word ?     ; current size of input buffer
>000c					cibp:    .word ?     ; index of current char in input buffer
>000e					input_f  .byte ?     ; input flag for Reader, see details there
>000f					tkblen:  .word ?     ; current size of the token buffer
>0011					tkbp:    .word ?     ; index of current token in token buffer
>0013					hp:      .word ?     ; pointer to next free heap entry
>0015					symtbl:  .word ?     ; pointer to first entry in symbol table in heap
>0017					strtbl:  .word ?     ; pointer to first entry in string table in heap
>0019					bnmtbl:  .word ?     ; pointer to first entry in bignum table in heap
>001b					ast      .word ?     ; pointer to root of Abstract Systax Tree (AST)
>001d					astp     .word ?     ; pointer to current entry in AST
>0200					cib:    .fill cib_size          ; current input buffer
>0300					tkb:    .fill tkb_size          ; token buffer
>0400					heap:   .fill heap_size         ; RAM available for heap
=$00					OT_META         = $00    ; used for end of input and other markers
=$10					OT_BOOL         = $10    ; used for #t and #f; immediate
=$20					OT_FIXNUM       = $20    ; used for fixed numbers; immediate
=$30					OT_BIGNUM       = $30    ; used for bignum
=$40					OT_CHAR         = $40    ; used for chars; immediate
=$50					OT_STRING       = $50
=$60					ot_undefined_06 = $60
=$70					ot_undefined_07 = $70
=$80					ot_undefined_08 = $80
=$90					ot_undefined_09 = $90
=$a0					ot_undefined_0a = $a0
=$b0					ot_undefined_0b = $b0
=$c0					ot_undefined_0c = $c0
=$d0					ot_undefined_0d = $d0
=$e0					ot_undefined_0e = $e0
=$f0					ot_undefined_0f = $f0

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../headers.asm

.8576					h_newline:
>8576	00 00				        .addr 0000              ; end of header list
>8578	5e 84				        .addr proc_newline
>857a	07				        .byte 7
>857b	6e 65 77 6c 69 6e 65		        .text "newline"

;******  Return to file: platforms/platform-py65mon.asm


;******  Processing file: platforms/../strings.asm

=0					str_unbound    = 0
=1					str_unspec     = 1
=2					str_true       = 2
=3					str_false      = 3
=4					str_bad_token  = 4
=5					str_bad_object = 5
=6					str_bad_number = 6
=7					str_bad_radix  = 7
=8					str_cant_yet   = 8      ; TODO temp during development
=9					str_end_input  = 9
=10					str_chant      = 10
.8582					string_table:
>8582	98 85 ac 85 c6 85 c9 85		        .word s_unbound, s_unspec, s_true, s_false      ; 0-3
>858a	cc 85 e0 85 fb 85 11 86		        .word s_bad_token, s_bad_object, s_bad_number, s_bad_radix   ; 4-7
>8592	25 86 3e 86 5b 86		        .word s_cant_yet, s_end_input, s_chant                       ; 8-11
>8598	3b 55 6e 62 6f 75 6e 64		s_unbound:      .null   ";Unbound variable: "           ; REPL input error
>85a0	20 76 61 72 69 61 62 6c 65 3a 20 00
>85ac	3b 55 6e 73 70 65 63 69		s_unspec:       .null   ";Unspecified return value"     ; used eg with (display)
>85b4	66 69 65 64 20 72 65 74 75 72 6e 20 76 61 6c 75
>85c4	65 00
>85c6	23 74 00			s_true:         .null   "#t"
>85c9	23 66 00			s_false:        .null   "#f"
>85cc	50 41 4e 49 43 3a 20 42		s_bad_token:    .null   "PANIC: Bad token: $"           ; from parser
>85d4	61 64 20 74 6f 6b 65 6e 3a 20 24 00
>85e0	50 41 4e 49 43 3a 20 42		s_bad_object:   .null   "PANIC: Bad object in AST: "    ; from printer
>85e8	61 64 20 6f 62 6a 65 63 74 20 69 6e 20 41 53 54
>85f8	3a 20 00
>85fb	3b 49 6c 6c 2d 66 6f 72		s_bad_number:   .null   ";Ill-formed number: $"         ; from lexer
>8603	6d 65 64 20 6e 75 6d 62 65 72 3a 20 24 00
>8611	50 41 4e 49 43 3a 20 42		s_bad_radix:    .null   "PANIC: Bad radix: $"           ; from parser
>8619	61 64 20 72 61 64 69 78 3a 20 24 00
>8625	41 4c 50 48 41 3a 20 43		s_cant_yet      .null   "ALPHA: Can't do that yet"      ; from parser
>862d	61 6e 27 74 20 64 6f 20 74 68 61 74 20 79 65 74
>863d	00
>863e	45 6e 64 20 6f 66 20 69		s_end_input     .null   "End of input stream reached."  ; from reader
>8646	6e 70 75 74 20 73 74 72 65 61 6d 20 72 65 61 63
>8656	68 65 64 2e 00
>865b	50 68 27 6e 67 6c 75 69		s_chant         .null   "Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn."   ; from reader
>8663	20 6d 67 6c 77 27 6e 61 66 68 20 43 74 68 75 6c
>8673	68 75 20 52 27 6c 79 65 68 20 77 67 61 68 27 6e
>8683	61 67 6c 20 66 68 74 61 67 6e 2e 00
>868f	21 24 25 26 2a 2b 2d 2e		s_extended:     .null "!$%&*+-./:<=>?@^_~"
>8697	2f 3a 3c 3d 3e 3f 40 5e 5f 7e 00

;******  Return to file: platforms/platform-py65mon.asm

>f000					.fill io_size                           ; Save space for the py65mon I/O
.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp cthulhu
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_quit:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	43 74 68 75 6c 68 75 20		        .null "Cthulhu Scheme default kernel for py65mon (13. Apr 2020)", Asclf
>f034	53 63 68 65 6d 65 20 64 65 66 61 75 6c 74 20 6b
>f044	65 72 6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f
>f054	6e 20 28 31 33 2e 20 41 70 72 20 32 30 32 30 29
>f064	0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
