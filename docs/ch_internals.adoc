[quote, Paul R Wilson, An Introduction to Scheme and its Implementation] 
The first field of a pair is called the `car` field, and the second field is
called the `cdr` field. These are among the dumbest names for anything in all of
computer science.<<PW>> 

// -------------------------------------------------------
=== Design descisions

One of the first questions is how to represent the objects of the language --
lists, integers, strings, symbols, etc. Usually in Lisp/Scheme, this is handled
by a machine word that is split into a tag part and a pointer or immediate part,
depending on the object in question. 

// TODO https://common-lisp.net/project/ecl/static/manual/ch35.html#Internals-Objects-representation
// TODO add image

We immediately see the challenges of running Scheme on an 8-bit machine with
small register, address, and word sizes. Even earliest version of Lisp was
envisioned for a machine with a 36-bit word size and 15-bit pointers, the IBM
701.<<JM1>> It was first link:https://en.wikipedia.org/wiki/IBM_704[actually
implemented] on an IBM 704 with the same word size.<<JM2>> We have less to work
with then the first Lispers back in 1960. 

For Cthulhu Scheme, we use a 16-bit object size, reserving the hightest nibble
(four bits, 15-12) for the tag and the remaining 12 bits for either the
immediate value (such as characters and fixnums) or a pointer to the value on
the heap (such as lists or strings). We discussion objects at greater detail
lower down. 

// -------------------------------------------------------
=== Memory Map

[quote, John McCarthy _et al_, Lisp I Programmer's Manual]
The current basic LISP system uses about 12,000 of the 32,000 memory (words) of
the (IBM) 704.
<<JM2>>

The basic big, simple split in Cthulhu Scheme is between things that go in RAM
and things that go in ROM. The code attempts to use the section functions of the
64tass assembler to make the best possible use of both. 

NOTE: We currently reserve half of the Zero Page area to allow for variables
that a user's kernel might use. This might change in the future if Cthulhu needs
more Zero Page memory. 

// TODO add segment map of RAM 
image::pics/memory_map.png[]

==== RAM Segments

A Cthulhu Scheme object consists of a four bit tag (bits 15 to 12) and a 12 bit
pointer to the object in the heap (bits 11 to 0). With twelve bits, we can 
address 4 Kbit of RAM. Because of this, the available RAM is divided into
segments. Each is numbered by the leading nibble from 0 to $F. These do not
eactly correspond to the tag nibbles. Currently, we have

- 0 ($0000 to $0FFF): Reserved for Zero Page, Stack, and buffers
- 1 ($1000 to $1FFF): Default AST segment (`rsn_ast`)
- 2 ($2000 to $2FFF): Default string segment (`rsn_str`)

As Cthulhu progresses, other segments will be assigned for symbols, bignums and
procedures.

Everything above segment 8 ($8000) is ROM. Segment 7 ($7000 to $7FFF) is
reserved for garbage collection in the future. 

NOTE: Though it is way too early in the development process to think about
garbage collection, one possible way would be to reserve one 4 KiB segment for
reorganizing once one of the other segments fills up. 


// -------------------------------------------------------
=== Compiler stuff

The classic structure of a Lisp or Scheme program are linked pairs. Our Abstract
Syntax Tree (AST) uses this structure internally with two 16-bit values that
follow each other: The first one is the `cdr`, the second one the `car`. 

NOTE: As the quote at the beginning of this section indicates, both terms (and
the `cons` procedure are incredibly stupid and probably have done a lot to keep
people away from Lisp and Scheme. However, there is simply no way around them at
this lower level. 

We keep the term AST for the part of memory and the structures that are involved
in the actual program. 

NOTE: During very early development, Cthulhu Lisp used a different system for
the AST as scaffolding. This was used until the mechanics for pair processing
were in place.  

In theory, we could construct other parts such as the string table from linked
lists as well. However, for reasons of efficiency, we currently use other
structures.



// -------------------------------------------------------
=== The REPL

The heart of any Scheme or Lisp system is the Read-Evaluate-Print Loop (REPL).
We follow the more standard terms reading, lexing (tokenizing), parsing,
evaluation, and printing.

==== Reader

Cthulhu Scheme takes the input from the *input port* and saves it as a single line in
the *input buffer*. 

NOTE: Currently, Cthulhu Scheme does not have a history function, though the
code could easily be lifted from Tali Forth 2. We are waiting to see how much
RAM we have left over after the system is complete for that step.

==== Lexer 

The Lexer (Tokenizer) passes through the characters and creates 8-bit tokens
which are stored in the *token buffer*. There is some pre-processing going on
here, but not much.

==== Parser

The parser creates an Abstract Syntax Tree (AST) with homogeneous nodes based on
the description in _Language Implementation Patters_ by Terence Parr.<<TP>> Each
node consists of three 16-bit fields:

. A pointer to the *next node*. If there is no next node, this is `0000`. 
. The *Scheme object* of the node. This is constructed out of the token stream.
  See below for a more thorough discussion of objects.
. A pointer to the *children nodes*. If there are no children nodes, this is
`0000`. 

image::pics/ast_node.png[]

NOTE: This design currently uses more memory that it has to by including a
pointer to a child node even for objects like booleans that are immediate and
never have children. At the moment, this design is kept because it makes walking
the AST easier. In future versions, this will probaly be changed to handle
heterogeneous nodes, saving space.

==== Evaluator

In the next step, the AST is "walked" by the evaluator. 

The main routine for the evaluator is named `apply`. Its function is to take the
first element of the AST level as a procedure and run the children of the level
through it.

==== Printer

What is left over by the Evaluator is sent to the Printer. 


// -------------------------------------------------------

=== Scheme objects

==== Object types 

A four-bit tag gives us 16 possible object types

// TODO replace by table

* Meta (immediate, bit code $0)
* Booleans (immediate, bit code $1 )
* Fixnum (immediate, bit code $2)
* Bignum (pointer, bit code TODO)
* Character (immediate, bit code TODO)
* List (pointer, bit code TODO)
* Procedure (pointer, bit code 000) The bit code 000 was chosen to make
  detecting a procedure as fast as possible
* String (pointer, bit code TODO).
* Symbol (pointer, bit code TODO)

There are quite a number of object types missing here compared to normal list --
see for example the [GNU Guile data
types](https://www.gnu.org/software/guile/manual/html_node/Data-Types.html), but
some sacrifices had to be made.

===== Booleans

The `#t` (true) and `#f` (false) booleans are self-evaluating and therefore were
the first object that was implemented. Though formally, `#t` comes with the
object `$1111`, in practice we only check the LSB, that is, `$ff`. This might
change in future versions. The `#f` object is `$1000`. Neither have children in
the Abstract Syntax Tree (AST) created by the parser. 

// TODO add table of boolean object

Since booleans are simple, they are basically completely processed by the lexer
(tokenizer), which adds a dedicated token. 

===== Fixnum

Fixnumbers are signed integers that are small enought to fit into a an object,
that is, 12 bits. They are stored in two's complement. Since this is not where
the 65c02 expects the sign to be, we have to move it from bit 11 to bit 15 when
processing the fixnum. 

// TODO add graphic of a fixnum object

NOTE: At the moment, in fact, Cthulhu Scheme only knows about fixnums, since
there aren't any bignums yet. Also, fixnum processing is very rough. 

The **lexer** starts tokenizing a fixnum when it encounters a number as the first
character of a word and has not been flagged as a binary, octal, or hexadecimal
number. It adds a token marking the start of the word, followed by the ASCII
values of the next characters, until a delimiter is reached. Then it adds a
token marking the end of the world. If a character is not a legal decimal number
character, it throws an error.

The **parser** actually converts the string of characters to an internal number.
At a future date, the size of the number will determine if it is converted to a
fixnum or a bignum. Currently, the converted number is cut off brutally at bit
11 and the sign moved from bit 15 to bit 12. 

See
https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Fixnum-Operations.html
for a further discussion. 

===== Strings

Stings are **interned**, that is, the actual ASCII characters are stored on the
heap, zero-terminated. The link to beginning of the string is stored in two
places: The heap and the **string table**. This is used to compare a new string
to the already stored strings so we don't share the same entry twice. 


==== Procedures

There are two types of procedures in Cthulhu Scheme: _native procedures_ that
are coded in assembler and _non-native procedures_ (also _high-level
procedures_) that are provided in Scheme code and loaded during boot.


===== Built-in procedures

NOTE: Scheme and Lisp both insist in holding on to `car` and `cdr` as terms and
commands, which makes as much sense as the famously silly `umount` command in
the Unix bash shell. Though these are included as commands, Cthulhu Scheme and
especially this documentation uses `first` and `rest`. 

