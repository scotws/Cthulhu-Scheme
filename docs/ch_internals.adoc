[quote, Paul R Wilson, An Introduction to Scheme and its Implementation] 
The first field of a pair is called the `car` field, and the second field is
called the `cdr` field. These are among the dumbest names for anything in all of
computer science.<<PW>> 

// -------------------------------------------------------
=== Design descisions

One of the first questions is how to represent the objects of the language --
lists, integers, strings, symbols, etc. Usually in Lisp/Scheme, this is handled
by a machine word that is split into a tag part and a pointer or immediate part,
depending on the object in question. 

// TODO https://common-lisp.net/project/ecl/static/manual/ch35.html#Internals-Objects-representation
// TODO add image

We immediately see the challenges of running Scheme on an 8-bit machine with
small register, address, and word sizes. Even earliest version of Lisp was
envisioned for a machine with a 36-bit word size and 15-bit pointers, the IBM
701.<<JM1>> It was first [actually
implemented](https://en.wikipedia.org/wiki/IBM_704) on an IBM 704 with the same
word size.<<JM2>> We have less to work with then the first Lispers back in 1960. 

For Cthulhu Scheme, we use a 16-bit object size, reserving the hightest nibble
(four bits, 15-12) for the tag and the remaining 12 bits for either the
immediate value (such as characters and fixnums) or a pointer to the value on
the heap (such as lists or strings). We discussion objects at greater detail
lower down. 

// -------------------------------------------------------
=== Memory Map

[quote, John McCarthy _et al_, Lisp I Programmer's Manual]
The current basic LISP system uses about 12,000 of the 32,000 memory (words) of
the (IBM) 704.
<<JM2>>

The big, simple split in Cthulhu Scheme is between things that go in RAM and things that
go in ROM. The code attempts to use the section functions of the 64tass
assembler to make the best possible use of both. 

NOTE: We currently reserve half of the Zero Page area to allow for variables
that a user's kernel might use. This might change in the future if Cthulhu needs
more Zero Page memory. 

image::pics/memory_map.png[]

// -------------------------------------------------------
=== The REPL

The heart of any Scheme or Lisp system is the Read-Evaluate-Print Loop (REPL).
We follow the more standard terms reading, lexing (tokenizing), parsing,
evaluation, and printing.

==== Reader

Cthulhu Scheme takes the input from the *input port* and saves it as a single line in
the *input buffer*. 

NOTE: Currently, Cthulhu Scheme does not have a history function, though the
code could easily be lifted from Tali Forth 2. We are waiting to see how much
RAM we have left over after the system is complete for that step.

==== Lexer 

The Lexer (Tokenizer) passes through the characters and creates 8-bit tokens
which are stored in the *token buffer*. There is some pre-processing going on
here, but not much.

==== Parser

The parser creates an Abstract Syntax Tree (AST) with homogeneous nodes based on
the description in _Language Implementation Patters_ by Terence Parr.<<TP>> Each
node consists of three 16-bit fields:

. A pointer to the *next node*. If there is no next node, this is `0000`. 
. The *Scheme object* of the node. This is constructed out of the token stream.
  See below for a more thorough discussion of objects.
. A pointer to the *children nodes*. If there are no children nodes, this is
`0000`. 

image::pics/ast_node.png[]

NOTE: This design currently uses more memory that it has to by including a
pointer to a child node even for objects like booleans that are immediate and
never have children. At the moment, this design is kept because it makes walking
the AST easier. In future versions, this will probaly be changed to handle
heterogeneous nodes, saving space.

==== Evaluator

In the next step, the AST is "walked" by the evaluator. 

The main routine for the evaluator is named `apply`. Its function is to take the
first element of the AST level as a procedure and run the children of the level
through it.

==== Printer

What is left over by the Evaluator is sent to the Printer. 


// -------------------------------------------------------

=== Scheme objects

==== Object types 

A four-bit tag gives us 16 possible object types

// TODO replace by table

* Bignum (pointer, bit code TODO)
* Booleans (immediate, bit code TODO)
* Character (immediate, bit code TODO)
* Fixnum (immediate, bit code TODO)
* List (pointer, bit code TODO)
* Procedure (pointer, bit code 000) The bit code 000 was chosen to make
  detecting a procedure as fast as possible
* String (pointer, bit code TODO).
* Symbol (pointer, bit code TODO)

There are quite a number of object types missing here compared to normal list --
see for example the [GNU Guile data
types](https://www.gnu.org/software/guile/manual/html_node/Data-Types.html), but
some sacrifices had to be made.


==== Procedures

There are two types of procedures in Cthulhu Scheme: _native procedures_ that
are coded in assembler and _non-native procedures_ (also _high-level
procedures_) that are provided in Scheme code and loaded during boot.


===== Built-in procedures

NOTE: Scheme and Lisp both insist in holding on to `car` and `cdr` as terms and
commands, which makes as much sense as the famously silly `umount` command in
the Unix bash shell. Though these are included as commands, Cthulhu Scheme and
especially this documentation uses `first` and `rest`. 

